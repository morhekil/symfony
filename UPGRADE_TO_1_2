Upgrade from 1.1 to 1.2
=======================

This document describes the changes made in symfony 1.2 and what need
to be done to upgrade your symfony 1.1 projects.

>**CAUTION**
>symfony 1.2 is compatible with PHP 5.2.4 or later.
>It might also work with PHP 5.2.0 to 5.2.3 but there is no guarantee.

How to upgrade?
---------------

To upgrade a project:

  * If you don't use a SCM tool, please make a backup of your project.

  * Launch the `project:upgrade1.2` task from your project directory
    to perform an automatic upgrade:

        $ php symfony project:upgrade1.2

    This task can be launched several times without any side effect. Each time
    you upgrade to a new symfony 1.2 beta / RC or the final symfony 1.2, you
    have to launch this task.

  * You need to rebuild your models and forms due to some changes described
    below:

        $ php symfony propel:build-model
        $ php symfony propel:build-forms

The remaining sections explain the main changes made in symfony 1.2.

Propel
------

Propel has been upgraded to version 1.3, which replaces support for Creole
with PDO, and includes many new features including: object instance pooling,
master-slave connections, native nested-set support, and better date handling.

Due to the removal of Creole, the following classes are removed:

 *class name*             | *equivalent*
 ------------------------ | -------------------------------
 `sfCreoleDatabase`       | `sfPropelDatabase`
 `sfDebugConnection`      | `DebugPDO`
 `sfMessageSource_Creole` | `sfMessageSource_PDO`
 `sfCreoleSessionStorage` | `sfPDOSessionStorage`
 
The `propel:build-db` task has been removed as this functionality is provided by
`propel:insert-sql`.

The first step to upgrading is changing from Creole to PDO syntax in the
database configuration from the project `databases.yml` file.

Locate the following:

    [yml]
    all:
      propel:
        class:      sfPropelDatabase
        param:
          dsn:      mysql://username:password@localhost/example

Replace with the following:

    [yml]
    dev:
      propel:
        param: 
          classname: DebugPDO
     
    all:
      propel:
        class: sfPropelDatabase
        param:
          dsn:        mysql:dbname=example;host=localhost 
          username:   username
          password:   password
          encoding:   utf8
          persistent: true
          pooling:    true
          classname:  PropelPDO


Next, you must also upgrade the `propel.ini` with the pdo format dsn and updated
configuration options.

Locate the following:

    [ini]
    propel.database            = mysql
    propel.database.createUrl  = mysql://username:password@localhost/
    propel.database.url        = mysql://username:password@localhost/example

Replace with the following:

    [ini]
    propel.database            = mysql
    propel.database.driver     = mysql
    propel.database.url        = mysql:dbname=example;host=localhost
    propel.database.user       = username
    propel.database.password   = password
    propel.database.encoding   = utf8

Since the underlying api has changed quite a bit, you need to rebuild the
object model:

   $ php symfony propel:build-model

In most cases, this will be all that is required. If you have customized
object model classes, you may need to manually upgrade for the changes in
API from Creole to PDO. The upgrade task will attempt to change method
signatures to match the `Persistent` interface, by adding type hinting for
PropelPDO in `->save($con = null)` and `->delete($con = null)`.

Change instances of:

    [php]
    public function save($con = null)
    public function delete($con = null)

To add PropelPDO type hint:

    [php]
    public function save(PropelPDO $con = null)
    public function delete(PropelPDO $con = null)

The transaction api has change slightly: `->begin` has been renamed `->beginTransaction()`
and `->rollback()` has been renamed `->rollBack()`. Here are the differences:
 
`Creole`:

    [php]
    $con->begin();
    try {
      /* db logic */
      $con->commit();
    } catch (SQLException $sqle) {
      $con->rollback();
      throw $sqle;
    }
    
`PDO`:

    [php]
    $con->beginTransaction();
    try {
      /* db logic */
      $con->commit();
    } catch (PDOException $sqle) {
      $con->rollBack();
      throw $sqle;
    }

The `::doSelectRS` method has been renamed to `::doSelectStmt`. Here are the differences:

`Creole`:

    [php]
    // example of how to manually hydrate objects
    $rs = AuthorPeer::doSelectRS(new Criteria());
    while($rs->next()) {
      $a = new Author();
      $a->hydrate($rs);
    }

    // example of how to create array of single column
    $rs = AuthorPeer::doSelectRS(new Criteria());
    $names = array();
    while($rs->next()) {
      $names[] = $rs->getString(2);
    }
    
    $con = Propel::getConnection(SomeTablePeer::DATABASE_NAME);
    $stmt = $con->prepareStatement("SELECT * FROM some_table WHERE name = ?");
    $stmt->setString(1, $name);
    $rs = $stmt->executeQuery();
    while($rs->next()) {
       print "Name: " . $rs->getString("name") . "\n";
    }


`PDO`:

    [php]
    // example of how to manually hydrate objects
    $stmt = AuthorPeer::doSelectStmt(new Criteria());
    while($row = $stmt->fetch(PDO::FETCH_NUM)) {
      $a = new Author();
      $a->hydrate($row);
    }
    
    // example of how to create array of single column
    $stmt = AuthorPeer::doSelectStmt(new Criteria());
    $names = array();
    while($res = $stmt->fetchColumn(1)) {
      $names[] = $res;
    }
    
    $con = Propel::getConnection(SomeTablePeer::DATABASE_NAME);
    $stmt = $con->prepare("SELECT * FROM some_table WHERE name = ?");
    $stmt->bindValue(1, $name);
    $stmt->execute();
    while($row = $stmt->fetch()) { 
       print "Name: " . $row['name'] . "\n";
    }


See http://propel.phpdb.org/trac/wiki/Users/Documentation/1.3/Upgrading for more details
on upgrading and http://propel.phpdb.org/trac/wiki/Users/Documentation/1.3 for the full
complete documentation.

All the Propel library have been moved from `lib/propel` to `lib`. The upgrade task
upgrades the `propel.ini` file to reflect these changes.

Action
------

In an action, you can now generate a URL by using the routing object directly
by calling `generateUrl()`:

    [php]
    public function executeIndex()
    {
      $this->redirect($this->generateUrl('homepage'));
    }

The `generateUrl()` method takes a route name, an array of parameters, and
whether to generate an absolute URL as its constructor arguments.

Request
-------

The `path_info_array`, `path_info_key`, and `relative_url_root` settings have
been moved from `settings.yml` to `factories.yml` (in the `param` section of the
`request` factory configuration).

This change removes the dependency between `sfRequest` and `sfConfig`.

These three request options are now passed to the request constructor as a
fourth argument. The formats are also passed as an option,
instead of being passed as an attribute.

The request method constants from `sfRequest` values have changed from integers
to strings and the `sfRequest::NONE` method has been removed:

 **Constant** | **Old value** | **New value**
 ------------ | ------------- | -------------
 GET          | 2             | GET
 POST         | 4             | POST
 PUT          | 5             | PUT
 DELETE       | 6             | DELETE
 HEAD         | 7             | HEAD
 NONE         | 1             | -

The `getMethod()` and `getMethodName()` methods now returns the same value,
so `getMethodName()` is deprecated.

The `sfAction::getMethodNames()` and the corresponding code in
`sfValidationExecutionFilter` from `sfCompat10Plugin` have been removed.
This method was deprecated in 1.1 and was not really useable in 1.0.

You can now simulate `PUT` and `DELETE` requests from a browser by using the
`POST` method and adding a special `sf_method` parameter:

    [php]
    <form action="#" method="POST">
      <input type="hidden" name="sf_method" value="PUT" />

      <!-- // ... -->
    </form>

The `form_tag()` helper has been updated to automatically generate the hidden
tag for methods different form `GET` and `POST`. So, the opening `form` tag
from the code above can be generated by using the `form_tag()` helper like this:

    [php]
    <?php echo form_tag('#', array('method' => 'PUT')) ?>

Forms
-----

The new `sfForm::renderFormTag()` method generates the opening
`form` tag for the current form. It also adds the `enctype`
attribute if the form needs to be multipart and adds a
hidden tag if the form method is not `GET` or `POST`:

    [php]
    <?php echo $form->renderFormTag('@article_update', array('method' => 'PUT')) ?>

The `sfFormPropel` class overrides `renderFormTag()` to automatically change
the HTTP method based on the related object: if the object is new, the method
will be `POST`, and if the object already exists, the method will be `PUT`.

A way to pre-process the cleaned up values before they are used by Propel to
update the object has been added to `sfFormPropel`.

If you want to pre-process a value, you need to add an `updateXXXColumn()` method
to your form where XXX is the PHP name of the Propel column.

The method must return the processed value or `false` to remove the value from
the array of cleaned up values:

    [php]
    class UserForm extends sfFormPropel
    {
      // ...

      protected function updateProfilePhotoColumn($value)
      {
        // if the user has not submitted a profile_photo,
        // remove the value from the values as we want
        // to keep the old one
        if (!$value)
        {
          return false;
        }

        // remove the old photo
        // save the photo on the disk

        // change the value to the new file name
        return $filename;
      }
    }

The `sfValidatedFile` class has been made a bit more flexible when it saves
the file.

Its constructor takes a new argument, the path to use when saving the file.

So, when saving a file, you can now:

 * pass an absolute filename as before

        [php]
        $file->save(sfConfig::get('sf_uploads_dir').'/filename.pdf');

 * pass a relative path (symfony will make it absolute by prepending the path)

        [php]
        $file->save('filename.pdf');

 * pass `null`. The filename will be autogenerated by the `generateFilename()`
   method.

        [php]
        $file->save();

Moreover, the `save()` method now returns the filename of the saved
file (relative to the path argument).

As the `sfValidatedFile` object is created by the `sfValidatorFile` validator,
a new `path` option has been added to the latter and is simply passed to the
`sfValidatedFile` constructor:

    [php]
    $this->validatorSchema['file'] = new sfValidatorFile(array('path' => sfConfig::get('sf_uploads_dir')));

The `sfFormPropel` takes advantages of these new enhancements to automate
the saving of the files related to a Propel object, thanks to the new
`saveUploadedFile()` method.

So, if you have a Propel object with a `file` column, and if you pass a path
when defining the `file` validator in your form, symfony will take care of
everything for you:

  * if no file is uploaded in the form
    * do nothing and do not change anything in the database

  * if a file is uploaded in the form
    * remove the old file
    * save the new one
    * set the `file` column to the filename (relative to the given path)

So, in the related action, you can now just use `$this->form->save()`
to save the object and save the file automatically.

By default, symfony will generate a unique file name by computing
a hash and adding the guessed extension. If you want to change the filename,
you can simply create a `generateXXXFilename()` method in your object
where XXX is the PHP name of the column. The method is given the
`sfValidatedFile` object:

    [php]
    public function generateFileFilename(sfValidatedFile $file)
    {
      return $this->getId().$file->getExtension($file->getOriginalExtension());
    }

You can of course also create a `updateXXXColumn()` as we have seen before to
override this behavior and manage the file uploading process by yourself.

There is a new `sfWidgetFormSelectCheckbox` widget which is similar to
`sfWidgetFormSelectRadio`.

There are also a new `choice` widget family:

  * `sfWidgetFormChoice`
  * `sfWidgetFormChoiceMany`
  * `sfWidgetFormPropelChoice`
  * `sfWidgetFormPropelChoiceMany`

By default, these widgets behave like their `Select` counterpart. But they are
a wrapper on top of the `sfWidgetFormSelect`, `sfWidgetFormSelectRadio`, and
`sfWidgetFormSelectCheckbox` widgets. They use one of these three widgets for the
rendering. To change the default widget, you have some options:

  * `expanded`:
    *  if false, then the widget will be a `select` tag
    *  if true and `multiple` is false, then the widget will be a list of `radio` tags
    *  if true and `multiple` is true, then the widget will be a list of `checkbox` tags
  * `renderer_options`: When creating the widget (`select`, `radio`, `checkbox`),
                        this is the options you want to pass to the renderer widget
  * `renderer_class`:   The class to use instead of the default one
  * `renderer`: You can also pass a widget object directly (this overrides
                the previous options).

Here are some example:

    [php]
    $widget = new sfWidgetFormPropelSelect(array('model' => 'Article'));

    // is equivalent to
    $widget = new sfWidgetFormPropelChoice(array('model' => 'Article'));

    // change the rendering to use a radio list
    $widget->setOption('expanded', true);

    // create a multiple select
    $widget = new sfWidgetFormPropelChoiceMany(array('model' => 'Article'));

    // change the rendering to use a checkbox list
    $widget->setOption('expanded', true);

These new widgets are now used by default for the Propel generated forms.

Response
--------

There is a new setting for the `response` factory: `send_http_headers`.
This setting is `true` by default, except for the `test` environment where
the headers must not be sent by PHP (the same goal was achieved by using
the `sf_test` setting in symfony 1.1).

This change removes the dependency between `sfResponse` and `sfConfig`.

The response has a new method, `getCharset()`, which returns the current
charset for the response. This charset is automatically updated if
you change it by setting the content type.

The `getStylesheets()` and `getJavascripts()` methods can now return all the
stylesheets and javascripts ordered by position if you pass `sfWebResponse::ALL`
as their first argument:

    [php]
    $response = new sfWebResponse(new sfEventDispatcher());
    $response->addStylesheet('foo.css');
    $response->addStylesheet('bar.css', 'first');

    var_export($response->getStylesheets());

    // outputs
    array(
      'bar.css' => array(),
      'foo.css' => array(),
    )

The `sfWebResponse::ALL` is also now the default value for the position argument.
In symfony 1.1, as the default value is the empty string, the methods only return
the files registered for the default position by default, which is not very intuitive.

In symfony 1.1, you was able to get all the files by passing the `'ALL'` string
as the position, and this behavior is still available by passing
`sfWebResponse::RAW`:

    [php]
    var_export($response->getStylesheets(sfWebResponse::RAW));

    // outputs
    array(
      'first' =>
        array(
          'bar.css' => array (),
        ),
      '' =>
        array(
        'foo.css' => array(),
        ),
      'last' => array(),
    )

All the positions (first, '', and last) are now also available as constants:

    [php]
    sfWebResponse::FIRST  === 'first'
    sfWebResponse::MIDDLE === ''
    sfWebResponse::LAST   === 'last'

The `removeStylesheet()` and `removeJavascript()` methods now only take one argument,
the file to remove from the response. It will remove the file in all the available
positions. In symfony 1.1, they take the position as a second argument.

Prototype and Scriptaculous
---------------------------

symfony continues to decouple its bundled software. In 1.2 the bundled Prototype 
and Scriptaculous libraries and helper (`JavascriptHelper`) have been moved to a 
core-plugin. Core plugins behave like real plugins but are shipped by symfony platform.
This will make the javscript and css files of the new `sfProtoculousPlugin` 
(the more or less inofficial name of the often featured duo) behave like real plugin
assets. They will be now in `web/sfProtoculousPlugin` rather than in `web/sf` 
(as it has been in 1.0 and 1.1). The `prototype_web_dir` setting will also now point 
to the new directory.

In addition some very basic javascript helpers that are reusable by any JS framework, have
been extracted to a `JavascriptBaseHelper` which stays in core.

>**CAUTION**
>**Work in progress:** As plugins are normally installed via a task and this invokes the 
>creation of the symlink in the web directory this is required for core plugins as well.
>To do this manually you need to invoke:
>
> ``symfony plugin:configure-core``
>
> The target is that the project creation and upgrade task do this for you


Validators
----------

The `sfValidatorSchemaCompare` constant values have been changed. No change to
your code need to be done, but now, you can use nice shortcuts.
The following two examples are equivalent:

    [php]
    // symfony 1.1 and 1.2
    $v = new sfValidatorSchemaCompare('left', sfValidatorSchemaCompare::EQUAL, 'right');

    // symfony 1.2 only
    $v = new sfValidatorSchemaCompare('left', '==', 'right');

`sfValidatorChoice` has now a `multiple` option to make it behave like a
`sfValidatorChoiceMany`.

`sfValidatorPropelChoice` has now a `multiple` option to make it behave like a
`sfValidatorPropelChoiceMany`.

Tests
-----

### Cookies

Cookies are now extensively supported in the `sfBrowser` and `sfTestBrowser`
classes.

You can manage cookies between requests by using the `setCookie()`,
`removeCookie()`, and `clearCookies()` methods of the `sfBrowser` class:

    [php]
    $b->
      setCookie('foo', 'bar')->
      removeCookie('bar')->
      get('/')->
      // ...

      clearCookies()->
      get('/')->
      // ...

You can also test cookies with the `hasCookie()` and `isCookie()` methods of
the `sfTestBrowser` class:

    [php]
    $b->
      get('/')->
      hasCookie('foo')->
      hasCookie('foobar', false)->
      isCookie('foo', 'bar')->
      isCookie('foo', '/a/')->
      isCookie('foo', '/!z/')->

The `hasCookie()` method takes a Boolean as its second argument to be able to
test the fact that a cookie is not set.

The second argument of the `isCookie()` method behaves as the second argument
of the `checkElementResponse` method. It can be a string, a regular expression,
or a negative regular expression.

The browser class also automatically expires cookies as per the `expire` value
of each cookie.

### Request

You can now test the HTTP method used by the request in your functional tests 
using the `isRequestMethod()` method of the `sfTestBrowser` class:

    [php]
    $b->
      setField('login', 'johndoe')->
      click('Submit')->
      isRequestMethod('post');

### Links

When you simulate a click on a button or on a link, you give the name to the `click()`
method. But you don't have the possibility to differentiate two different links or buttons
with the same name.

As of symfony 1.2, the `click()` method takes a third argument to pass some options.

You can pass a `position` option to change the link you want to click on:

    [php]
    $b->
      click('/', array(), array('position' => 1))->
      // ...
    ;

By default, symfony clicks on the first link it finds in the page.

You can also pass a `method` option to change the method of the link or the form
you are clicking on:

    [php]
    $b->
      click('/delete', array(), array('method' => 'delete'))->
      // ...
    ;

This is very useful when a link is converted to a dynamic form generated
with JavaScript.

YAML
----

The YAML parser now supports full merge key (see http://yaml.org/type/merge.html
for more examples).

    [php]
    $yaml = new sfYamlParser();

    var_export($yaml->parse(<<<EOF
    default_param: &default_param
      datasource: propel
      phptype:    mysql
      hostspec:   localhost
      database:   db
      username:   user
      password:   pass

    param:
      <<: *default_param
      username:   myuser
      password:   mypass
    EOF
    ));

    // outputs
    array(
      'default_param' => array(
        'datasource' => 'propel',
        'phptype'    => 'mysql',
        'hostspec'   => 'localhost',
        'database'   => 'db',
        'username'   => 'user',
        'password'   => 'pass',
      )

      'param' => array(
        'datasource' => 'propel',
        'phptype'    => 'mysql',
        'hostspec'   => 'localhost',
        'database'   => 'db',
        'username'   => 'myuser',
        'password'   => 'mypass',
      )
    )

Actions
-------

By default, when you use the `redirectIf()` or `redirectUnless()` methods
in your actions, symfony automatically changes the response HTTP status
code to 302.

These two methods now have an additional optional argument to change this
default status code:

    [php]
    $this->redirectIf($condition, '@homepage', 301);
    $this->redirectUnless($condition, '@homepage', 301);

The `redirect()` method already have this feature.

sfParameterHolder
-----------------

The `has()` method of `sfParameterHolder` has been changed to be more
semantically correct.

It now returns `true` even if the value is `null`:

    [php]
    $ph = new sfParameterHolder();
    $ph->set('foo', 'bar');
    $ph->set('bar', null);

    $ph->has('foo') === true;
    $ph->has('bar') === true; // returns false under symfony 1.0 or 1.1

The `sfParameterHolder::has()` method is used by the `hasParameter()` and
`hasAttribute()` methods available for a large number of core classes.

Loggers
-------

symfony 1.2 comes with a new built-in logger: `sfVarLogger`. This logger class
logs all the messages as an array for later use. It's up to you to get the logs
and do something with them:

    [php]
    $log = new sfVarLogger();
    $log->log('foo');

    var_export($log->getLogs());

    // outputs
    array(
      0 => array(
        'priority'      => 6,
        'priority_name' => 'info',
        'time'          => 1219385295,
        'message'       => 'foo',
        'type'          => 'sfOther',
        'debug_stack'   => array()
      )
    )

Each log is an associative array with the following keys: `priority`, `priority_name`,
`time`, `message`, `type`, and `debug_stack`.

The `debug_stack` attribute is only set if you turns the `xdebug_logging` option to `true`.
It then contains the stack trace returned by xdebug as an array.

The `sfVarLogger` is also the base class for the `sfWebDebugLogger` class. So, the
`xdebugLogging` option of `sfWebDebugLogger` has been renamed to `xdebug_logging`.

Web Debug Toolbar
-----------------

The web debug toolbar is now customizable. The toolbar is composed of panels. A panel is
an object that extends `sfWebDebugPanel` and provides all the needed information to display
if on the toolbar.

By default, the following panels are automatically registered:

 *name*          | *class name*
 --------------- | -------------------------------
 symfony_version | `sfWebDebugPanelSymfonyVersion`
 cache           | `sfWebDebugPanelCache`
 config          | `sfWebDebugPanelConfig`
 logs            | `sfWebDebugPanelLogs`
 time            | `sfWebDebugPanelTimer`
 memory          | `sfWebDebugPanelMemory`
 db              | `sfWebDebugPanelPropel`

You can customize the web debug toolbar by listening to the `debug.web.load_panels` event.
The listener can then add new panels, remove existing ones, or even replace some.

The `sfWebDebugPanelLogs` panel filters the logs to be displayed by notifying the
`debug.web.filter_logs` event.
For example, the `sfWebDebugPanelPropel` and `sfWebDebugPanelTimer` connect to this event
to remove all Propel related logs and timer logs from the logs panel.

The total time displayed on the web debug toolbar is now computed with `$_SERVER['REQUEST_TIME']`
(we used to compute it with `sfConfig::get('sf_time_start')`, which does not exist anymore).
This means that the time displayed will be much larger than in symfony 1.0 and 1.1.

Browser
-------

The `sfBrowser` and `sfTestBrowser` classes have been refactored in four classes:

  * `sfBrowserBase`:        The base browser class. It knows nothing about symfony,
                            except classes from the symfony platform.

  * `sfBrowser`:            It inherits from `sfBrowserBase` and implements the
                            methods specific to symfony.

  * `sfTestFunctionalBase`: The base functional test class. It implements test
                            methods that are independant from symfony.

  * `sfTestFunctional`:     It inherits from `sfTestFunctionalBase` and implements
                            the test methods specific to symfony.

  * `sfTestBrowser`:        A BC class which is the same as the `sfTestFunctional`
                            class with a constructor signature compatible with symfony 1.1

The idea behind the refactor is that the `sfTestFunctional` class is a test class,
not a browser. So, it takes a browser and a test object as its arguments:

    [php]
    $testBrowser = new sfTestBrowser('localhost');

    $tester = new sfTestFunctional(new sfBrowser('localhost'), new lime_test());

The `sfTestFunctional` class acts as a proxy for the browser class which means
that all methods from the browser are accessible directly from the tester object.

This refactor must not introduce backward incompatibility with symfony 1.1.

Tasks
-----

The Propel tasks relying on Phing now output a clear error message if the embed
Phing task fails.

Some CLI tasks takes an application name as an argument because they need to connect
to the database. We need an application because the configuration can be customized
on an application basis and all the symfony configuration system is based on the
application level.

For these tasks, this argument has been removed in favor of an optional "application"
option. If you don't provide the "application" option, symfony will take the database
configuration from the project `databases.yml` file.

The following task signatures have been changed accordingly:

 * `propel:build-all-load`
 * `propel:data-dump`
 * `propel:data-load`

>**Note**
>This is possible because `sfDatabaseManager` now takes a project configuration or an
application configuration. For the curious one, this works because
`sfDatabaseConfigHandler` now returns a static or a dynamic configuration based
on an array of configuration files (see the `execute()` and `evaluate()` methods).

The `propel:insert-sql` task removes all the data from the database.
As it destroys information, it now asks the user to confirm the execution of
the task. The same goes for the `propel:build-all` and `propel:build-all-load` tasks,
as they call the `propel:insert-sql` task.

If you want to use these tasks in a batch and want to avoid the confirmation question,
pass the `no-confirmation` option:

   $ php symfony propel:insert-sql --no-confirmation

The `sfTask` base class now provides three new methods to use in your tasks:

  * `logBlock()`:        Logs a message in a styled block
                         (default styles are: INFO, COMMENT, QUESTION, and ERROR)
  * `ask()`:             Asks a question to the user and returns the given answer
  * `askConfirmation()`: Asks a confirmation to the user and return true if the user
                         confirmed, false otherwise

The `propel:generate-crud` has been renamed to `propel:generate-module`. The old
task name is still available as an alias.

The `non-atomic-actions` option of `propel:generate-module` has been removed
and some new options have been added:

  * singular:          The singular name for the actions and templates
  * plural:            The plural name for the actions and templates
  * route-prefix:      The route prefix to use
  * with-propel-route: Whether the related routes are Propel aware

To ease the debugging, the `propel:build-model`, `propel:build-all`, and
`propel:build-all-load` tasks do not remove the generated XML schemas anymore
if you pass the `--trace` option.

The new `propel:generate-module-for-route` generates a module based on a route
definition:

    [php]
    php symfony propel:generate-module-for-route frontend articles

As symfony now can auto-generate routes (see below), the `app:routes` task
displays the list of current routes for an application:

    [php]
    php symfony app:routes frontend

If you want to get some details about a route, just add the route name:

    [php]
    php symfony app:routes frontend articles_update

Routing
-------

The `sfPatternRouting` class now stores its routes as an array of `sfRoute`
objects instead of a flat associative array.

By default, symfony uses the built-in `sfRoute` object, but you can change
it by specifying a `class` entry in your `routing.yml` configuration file:

    [yml]
    foo_bar:
      url:   /foo/:bar
      class: myRoute
      param: { module: foo, action: bar }

All the routing logic is contained in the `sfRoute` class, which means you
can override the parsing and the generation logic with your own.

>**TIP**
>The `sfRoute` class is much more modular than the old `sfPatternRouting` class
>to allow easier customization of the default behavior. The "compilation" phase
>has been refactored into smaller methods, the code has been simplified,
>and it is based on a "real" tokenizer.

If you connect your routes with PHP code, you must now pass a `sfRoute` instance
as the second argument for the `connect()`, `preprendRoute()`, `appendRoute()`,
and `insertRouteBefore()` methods:

    [php]
    $route = new myRoute('/foo/:bar', array('module' => 'foo', 'action' => 'bar'));
    $routing->connect('foo_bar', $route);

The `sfRoute` constructor takes an array of options as its last argument to
allow the customization of each route. In the `routing.yml` configuration file,
use to `options` key:

    [yml]
    article:
      url:     /article/:id-:slug
      options: { segment_separators: [/, ., -] }

Symfony has another built-in route, `sfRequestRoute`, which can enforce the
HTTP method for your routes:

    [yml]
    article:
      url:          /article/:id
      requirements: { sf_method: get }
      class:        sfRequestRoute

If you don't pass a `sf_method` requirement, symfony will enforces a `get`, or
a `head` request.

This is made possible because the `parse()` method of `sfRouting` now takes a
context as a second argument. When the request calls the routing, it passes
the following context:

  * `method`:      The HTTP method name
  * `format`:      The request format
  * `host`:        The hostname
  * `is_secure`:   Whether the request was called with HTTPS or not
  * `request_uri`: The full request URI
  * `prefix`:      The prefix to add to each generated route

With the previous routing configuration, the `article` route will only match
requests with a `get` HTTP method. If you define several routes with the same
`url` but different method requirements, you can pass `sf_method` as a parameter
when you generate a route:

    [php]
    <?php echo link_to('Great article', '@article?id=1&sf_method=get')) ?>

The routing takes two new options:

  * `generate_shortest_url`:            Whether to generate the shortest URL
                                        possible
  * `extra_parameters_as_query_string`: Whether to generate extra parameters
                                        as a query string

By default, they are set to `false` in the default `factories.yml` configuration
file to keep backward compatibility with symfony 1.0 and 1.1.

You can also enable or disable these options on a route basis:

    [yml]
    articles:
      url:     /articles/:page
      param:   { module: article, action: list, page: 1 }
      options: { generate_shortest_url: true }

This route will generate the shortest URL possible. So, if you pass a `page`
of `1`, the generated URL will be `/articles`:

    [php]
    echo url_for('@articles?page=1');
    // /articles
    // would have been /articles/1 in symfony 1.1

    echo url_for('@articles?page=2');
    // /articles/2

Here is an example for `extra_parameters_as_query_string`:

    [yml]
    articles:
      url:     /articles
      options: { extra_parameters_as_query_string: true }

This route will accept extra parameters and add them as a query string:

    [php]
    echo url_for('@articles?page=1');
    // /articles?page=1
    // would not have matched the route in symfony 1.1

    echo url_for('@articles?page=2');
    // /articles?page=2

symfony 1.2 comes with another route class that extends `sfRequestRoute`,
`sfObjectRoute`.

`sfObjectRoute` binds a route to a PHP object. A `sfObjectRoute` will
call some methods on your PHP class to get the object, or a collection of
objects, related to the route.

The object or the collection of objects will be available in your actions
via a request attribute:

    [yml]
    article:
      url:     /article/:id
      class:   sfObjectRoute
      options: { model: Article, object: article, method: getById }

When an incoming URL matches the route, the `sfObjectRoute` will get the
related object by calling the `Article::getById()` method and will inject
the result into the request attributes (under the `article` key).

The same goes for a collection of objects:

    [yml]
    articles:
      url:     /articles/newest
      class:   sfObjectRoute
      options: { model: Article, list: articles, method: getNewest }

`sfPropelRoute` extends `sfObjectRoute` to bind a route to a Propel model.

Here is an example for an `Article` Propel object:

    [yml]
    article:
      url:     /article/:id
      param:   { module: article, action: show }
      class:   sfPropelRoute
      options: { model: Article, object: article }

    articles:
      url:     /articles
      param:   { module: article, action: list }
      class:   sfPropelRoute
      options: { model: Article, list: articles, method: getPublishedArticleCriteria }

If you don't define a method, `sfPropelRoute` will retrieve the object
by building a Criteria object based on the available route variables.

The `sfPropelRoute` has two main advantages over `sfRoute`:

  * When a request comes in and the route matches the URL, `sfPropelRoute`
    will automatically inject the related `Article` object with a name of `article`.
    Moreover, if the object does not exist in the database, it will automatically
    redirect the user to a 404 error page. This means less boiler-plate code in
    your actions.

  * When you generate a link for this route, you can use the new `url_for()`
    signature and pass the article object directly for the parameters argument:

        [php]
        <?php echo url_for('article', $article) ?>

    If you have to pass extra parameters (to enforce a HTTP method for example),
    you can use an array like this:

        [php]
        <?php echo url_for('article', array('sf_subject' => $article, 'sf_method' => 'get')) ?>

    And of course, you can still use the full parameters:

        [php]
        <?php echo url_for('article', array('id' => $article->getId(), 'slug' => $article->getSlug())) ?>

    Or use the internal URI:

        [php]
        <?php echo url_for('@article?id='.$article->getId().'&slug='.$article->getSlug()) ?>

    The `sfPropelRoute` converts the article object to an array of parameters automatically.

`sfPropelRoute` does not only work with the primary key. It can also work with
any column. In the following example, let's add the `slug` column to the route
pattern:

    [yml]
    article:
      url:     /article/:id/:slug
      param:   { module: article, action: show }
      class:   sfPropelRoute
      options: { model: Article, object: article }

But sometimes, you want to put in the pattern some information that does not
exist in the database. In this case, you can pass a `method` option:

    [yml]
    post:
      url:     /post/:id/:year/:month/:day/:slug
      param:   { module: article, action: show }
      class:   sfPropelRoute
      options: { model: Article, object: article, method: getObjectForRoute }

The `getObjectForRoute()` receives an array of parameters as its first
argument and must return an `Article` object:

    [php]
    class ArticlePeer extends BaseArticlePeer
    {
      static public function getObjectForRoute($parameters)
      {
        $criteria = new Criteria();
        $criteria->add(self::ID, $parameters['id']);

        return self::doSelectOne($criteria);
      }
    }

URL helpers
-----------

If you want to create a link to a resource that must be submitted with the
`POST`, `PUT`, or `DELETE` HTTP method, the `link_to()` helper can convert
a link to a form if you pass the `method` option:

    [php]
    <?php echo link_to('@article_delete?id=1', array('method' => 'delete')) ?>

The old `post` option is still valid but deprecated:

    [php]
    // is deprecated
    <?php echo link_to('@some_route', array('post' => true)) ?>

    // and equivalent to
    <?php echo link_to('@some_route', array('method' => 'post')) ?>

The `url_for()` and `link_to()` helpers support new signatures.
Instead of an internal URI, they can now also take the route name and
an array of parameters:

    [php]
    echo url_for('@article', array('id' => 1));
    echo link_to('Link to article', '@article', array('id' => 1));

The old behavior still works without changing anything to your code.

Image helper
------------

In symfony 1.0 and 1.1 the `image_tag` helper would generate the `alt`
attribute of the img-tag from the filename. This now only happens if
`sf_compat_10` is on. The new behaviour eases finding of unset alt attributes
using a (x)html validator. As a bonus, there is now a `alt_title` option that
will set alt and title attribute to the same value, which is useful for cross
browser tooltips.

View Configuration
------------------

As of symfony 1.2, it is now possible to change the View class used by
symfony to render the partials by setting the `partial_view_class` in
`module.yml`. The class must extend `sfPartialView`. Similar to the
`view_class` setting, symfony will automatically appends `PartialView`
to the `partial_view_class` value:

    [yml]
    # module.yml
    all:
      partial_view_class: my

Factories
---------

The `sfViewCacheManager` class is now configurable in `factories.yml`:

    [yml]
    view_cache_manager:
      class: sfViewCacheManager

View
----

You can override `sfViewCacheManager::generateCacheKey()` by defining a
`sf_cache_namespace_callable` setting. As of symfony 1.2, the callable
is now called with an additional argument, the view cache manager instance.

Configuration
-------------

Before symfony 1.2, all the plugins installed under the `plugins` directory,
and all built-in plugins were automatically loaded.

As of symfony 1.2, you need to enable the plugins you want to use in your projects.
You can do this in your `ProjectConfiguration` class. Here is how to enable the
Doctrine plugin and disable the Propel one:

    [php]
    public function setup()
    {
      $this->enablePlugins('sfDoctrinePlugin');
      $this->disablePlugins('sfPropelPlugin');
    }

You can add several plugins in one call by passing an array of plugin names:

    [php]
    public function setup()
    {
      $this->enablePlugins(array('sfDoctrinePlugin', 'sfGuardPlugin'));
    }

You can also change the order in which plugins are loaded by using the `setPlugins`
method:

  [php]
  public function setup()
  {
    $this->setPlugins('sfDoctrinePlugin', 'sfCompat10Plugin');
  }

The `orm` setting is deprecated in `settings.yml` as it is now automatically
set when the ORM plugin is loaded.

The `compat_10` setting is also deprecated in `settings.yml` as it is now
automatically set when the `sfCompat10Plugin` is loaded.

So, to enable the 1.0 compatibility plugin, you need to enable it in your
configuration:

    [php]
    public function setup()
    {
      $this->enablePlugins('sfCompat10Plugin');
    }

By default, symfony only enables the Propel plugin.

You can also enable all installed plugins:

    [php]
    public function setup()
    {
      $this->enableAllPluginsExcept('sfDoctrinePlugin');
    }

The previous example allows you to enable all plugins except the Doctrine one.
If you upgrade from 1.0 or 1.1, this line will make symfony behave like in
symfony 1.0 and 1.1.
