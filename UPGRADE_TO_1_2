Upgrade from 1.1 to 1.2
=======================

This document describes the changes made in symfony 1.2 and what need
to be done to upgrade your symfony 1.1 projects.

>**CAUTION**
>symfony 1.2 is compatible with PHP 5.2.4 or later.
>It might also work with PHP 5.2.0 to 5.2.3 but there is no guarantee.

How to upgrade?
---------------

To upgrade a project:

  * If you don't use a SCM tool, please make a backup of your project.

  * Launch the `project:upgrade1.2` task from your project directory
    to perform an automatic upgrade:

        $ ./symfony project:upgrade1.2

    This task can be launched several times without any side effect. Each time
    you upgrade to a new symfony 1.2 beta / RC or the final symfony 1.2, you
    have to launch this task.

The remaining sections explain the main changes made in symfony 1.2.

Request
-------

The `path_info_array`, `path_info_key`, and `relative_url_root` settings have
been moved from `settings.yml` to `factories.yml` (in the `param` section of the
`request` factory configuration).

This change removes the dependency between `sfRequest` and `sfConfig`.

These three request options are now passed to the request constructor as a
fourth argument. The formats are also passed as an option,
instead of being passed as an attribute.

The request method constants from `sfRequest` values have changed from integers
to strings and the `sfRequest::NONE` method has been removed:

 **Constant** | **Old value** | **New value**
 ------------ | ------------- | -------------
 GET          | 2             | GET
 POST         | 4             | POST
 PUT          | 5             | PUT
 DELETE       | 6             | DELETE
 HEAD         | 7             | HEAD
 NONE         | 1             | -

The `getMethod()` and `getMethodName()` methods now returns the same value,
so `getMethodName()` is deprecated.

The `sfAction::getMethodNames()` and the corresponding code in
`sfValidationExecutionFilter` from `sfCompat10Plugin` have been removed.
This method was deprecated in 1.1 and was not really useable in 1.0.

You can now simulate `PUT` and `DELETE` requests from a browser by using the
`POST` method and adding a special `sf_method` parameter:

    [php]
    <form action="#" method="POST">
      <input type="hidden" name="sf_method" value="PUT" />

      <!-- // ... -->
    </form>

Response
--------

There is a new setting for the `response` factory: `send_http_headers`.
This setting is `true` by default, except for the `test` environment where
the headers must not be sent by PHP (the same goal was achieved by using
the `sf_test` setting in symfony 1.1).

This change removes the dependency between `sfResponse` and `sfConfig`.

The response has a new method, `getCharset()`, which returns the current
charset for the response. This charset is automatically updated if
you change it by setting the content type.

The `getStylesheets()` and `getJavascripts()` methods can now return all the
stylesheets and javascripts ordered by position if you pass `sfWebResponse::ALL`
as their first argument:

    [php]
    $response = new sfWebResponse(new sfEventDispatcher());
    $response->addStylesheet('foo.css');
    $response->addStylesheet('bar.css', 'first');

    var_export($response->getStylesheets());

    // outputs
    array(
      'bar.css' => array(),
      'foo.css' => array(),
    )

The `sfWebResponse::ALL` is also now the default value for the position argument.
In symfony 1.1, as the default value is the empty string, the methods only return
the files registered for the default position by default, which is not very intuitive.

In symfony 1.1, you was able to get all the files by passing the `'ALL'` string
as the position, and this behavior is still available by passing
`sfWebResponse::RAW`:

    [php]
    var_export($response->getStylesheets(sfWebResponse::RAW));

    // outputs
    array(
      'first' =>
        array(
          'bar.css' => array (),
        ),
      '' =>
        array(
        'foo.css' => array(),
        ),
      'last' => array(),
    )

All the positions (first, '', and last) are now also available as constants:

    [php]
    sfWebResponse::FIRST  === 'first'
    sfWebResponse::MIDDLE === ''
    sfWebResponse::LAST   === 'last'

The `removeStylesheet()` and `removeJavascript()` methods now only take one argument,
the file to remove from the response. It will remove the file in all the available
positions. In symfony 1.1, they take the position as a second argument.

Prototype and Scriptaculous
---------------------------

symfony continues to decouple its bundled software. In 1.2 the bundled Prototype and 
Scriptaculous libraries and helper (`JavascriptHelper`) have been moved to a core-plugin.
Core plugins behave like real plugins but are shipped by symfony platform. This will make
the javscript and css files of the new `sfProtoculousPlugin` (the more or less inofficial 
name of the often featured duo) behave like real plugin assets. They will be now in 
`web/sfProtoculousPlugin` rather than in `web/sf` (as it has been in 1.0 and 1.1). The 
`prototype_web_dir` setting will also now point tot the new directory.

>**CAUTION**
>**Work in progress:** As plugins are normally installed via a task and this invokes the 
>creation of the symlink in the web directory this is required for core plugins as well.
>To do this manually you need to invoke:
>
> ``symfony plugin:configure-core``
>
> The target is that the project creation and upgrade task do this for you


Validators
----------

The `sfValidatorSchemaCompare` constant values have been changed. No change to
your code need to be done, but now, you can use nice shortcuts.
The following two examples are equivalent:

    [php]
    // symfony 1.1 and 1.2
    $v = new sfValidatorSchemaCompare('left', sfValidatorSchemaCompare::EQUAL, 'right');

    // symfony 1.2 only
    $v = new sfValidatorSchemaCompare('left', '==', 'right');

Tests
-----

### Cookies

Cookies are now extensively supported in the `sfBrowser` and `sfTestBrowser`
classes.

You can manage cookies between requests by using the `setCookie()`,
`removeCookie()`, and `clearCookies()` methods of the `sfBrowser` class:

    [php]
    $b->
      setCookie('foo', 'bar')->
      removeCookie('bar')->
      get('/')->
      // ...

      clearCookies()->
      get('/')->
      // ...

You can also test cookies with the `hasCookie()` and `isCookie()` methods of
the `sfTestBrowser` class:

    [php]
    $b->
      get('/')->
      hasCookie('foo')->
      hasCookie('foobar', false)->
      isCookie('foo', 'bar')->
      isCookie('foo', '/a/')->
      isCookie('foo', '/!z/')->

The `hasCookie()` method takes a Boolean as its second argument to be able to
test the fact that a cookie is not set.

The second argument of the `isCookie()` method behaves as the second argument
of the `checkElementResponse` method. It can be a string, a regular expression,
or a negative regular expression.

The browser class also automatically expires cookies as per the `expire` value
of each cookie.

### Links

When you simulate a click on a button or on a link, you give the name to the `click()`
method. But you don't have the possibility to differentiate two different links or buttons
with the same name.

As of symfony 1.2, the `click()` method takes a third argument to tell the position of
the link you want to click on the page:

    [php]
    $b->
      click('/', array(), 1)->
      // ...
    ;

By default, symfony clicks on the first link it finds in the page.

YAML
----

The YAML parser now supports full merge key (see http://yaml.org/type/merge.html
for more examples).

    [php]
    $yaml = new sfYamlParser();

    var_export($yaml->parse(<<<EOF
    default_param: &default_param
      datasource: propel
      phptype:    mysql
      hostspec:   localhost
      database:   db
      username:   user
      password:   pass

    param:
      <<: *default_param
      username:   myuser
      password:   mypass
    EOF
    ));

    // outputs
    array(
      'default_param' => array(
        'datasource' => 'propel',
        'phptype'    => 'mysql',
        'hostspec'   => 'localhost',
        'database'   => 'db',
        'username'   => 'user',
        'password'   => 'pass',
      )

      'param' => array(
        'datasource' => 'propel',
        'phptype'    => 'mysql',
        'hostspec'   => 'localhost',
        'database'   => 'db',
        'username'   => 'myuser',
        'password'   => 'mypass',
      )
    )

Actions
-------

By default, when you use the `redirectIf()` or `redirectUnless()` methods
in your actions, symfony automatically changes the response HTTP status
code to 302.

These two methods now have an additional optional argument to change this
default status code:

    [php]
    $this->redirectIf($condition, '@homepage', 301);
    $this->redirectUnless($condition, '@homepage', 301);

The `redirect()` method already have this feature.

sfParameterHolder
-----------------

The `has()` method of `sfParameterHolder` has been changed to be more
semantically correct.

It now returns `true` even if the value is `null`:

    [php]
    $ph = new sfParameterHolder();
    $ph->set('foo', 'bar');
    $ph->set('bar', null);

    $ph->has('foo') === true;
    $ph->has('bar') === true; // returns false under symfony 1.0 or 1.1

The `sfParameterHolder::has()` method is used by the `hasParameter()` and
`hasAttribute()` methods available for a large number of core classes.

Loggers
-------

symfony 1.2 comes with a new built-in logger: `sfVarLogger`. This logger class
logs all the messages as an array for later use. It's up to you to get the logs
and do something with them:

    [php]
    $log = new sfVarLogger();
    $log->log('foo');

    var_export($log->getLogs());

    // outputs
    array(
      0 => array(
        'priority'      => 6,
        'priority_name' => 'info',
        'time'          => 1219385295,
        'message'       => 'foo',
        'type'          => 'sfOther',
        'debug_stack'   => array()
      )
    )

Each log is an associative array with the following keys: `priority`, `priority_name`,
`time`, `message`, `type`, and `debug_stack`.

The `debug_stack` attribute is only set if you turns the `xdebug_logging` option to `true`.
It then contains the stack trace returned by xdebug as an array.

The `sfVarLogger` is also the base class for the `sfWebDebugLogger` class. So, the
`xdebugLogging` option of `sfWebDebugLogger` has been renamed to `xdebug_logging`.

Web Debug Toolbar
-----------------

The web debug toolbar is now customizable. The toolbar is composed of panels. A panel is
an object that extends `sfWebDebugPanel` and provides all the needed information to display
if on the toolbar.

By default, the following panels are automatically registered:

 *name*          | *class name*
 --------------- | -------------------------------
 symfony_version | `sfWebDebugPanelSymfonyVersion`
 cache           | `sfWebDebugPanelCache`
 config          | `sfWebDebugPanelConfig`
 logs            | `sfWebDebugPanelLogs`
 time            | `sfWebDebugPanelTimer`
 memory          | `sfWebDebugPanelMemory`
 db              | `sfWebDebugPanelPropel`

You can customize the web debug toolbar by listening to the `debug.web.load_panels` event.
The listener can then add new panels, remove existing ones, or even replace some.

The `sfWebDebugPanelLogs` panel filters the logs to be displayed by notifying the
`debug.web.filter_logs` event.
For example, the `sfWebDebugPanelPropel` and `sfWebDebugPanelTimer` connect to this event
to remove all Propel related logs and timer logs from the logs panel.

The total time displayed on the web debug toolbar is now computed with `$_SERVER['REQUEST_TIME']`
(we used to compute it with `sfConfig::get('sf_time_start')`, which does not exist anymore).
This means that the time displayed will be much larger than in symfony 1.0 and 1.1.

Browser
-------

The `sfBrowser` and `sfTestBrowser` classes have been refactored in four classes:

  * `sfBrowserBase`:        The base browser class. It knows nothing about symfony,
                            except classes from the symfony platform.

  * `sfBrowser`:            It inherits from `sfBrowserBase` and implements the
                            methods specific to symfony.

  * `sfTestFunctionalBase`: The base functional test class. It implements test
                            methods that are independant from symfony.

  * `sfTestFunctional`:     It inherits from `sfTestFunctionalBase` and implements
                            the test methods specific to symfony.

  * `sfTestBrowser`:        A BC class which is the same as the `sfTestFunctional`
                            class with a constructor signature compatible with symfony 1.1

The idea behind the refactor is that the `sfTestFunctional` class is a test class,
not a browser. So, it takes a browser and a test object as its arguments:

    [php]
    $testBrowser = new sfTestBrowser('localhost');

    $tester = new sfTestFunctional(new sfBrowser('localhost'), new lime_test());

The `sfTestFunctional` class acts as a proxy for the browser class which means
that all methods from the browser are accessible directly from the tester object.

This refactor must not introduce backward incompatibility with symfony 1.1.

Tasks
-----

Some CLI tasks takes an application name as an argument because they need to connect
to the database. We need an application because the configuration can be customized
on an application basis and all the symfony configuration system is based on the
application level.

For these tasks, this argument has been removed in favor of an optional "application"
option. If you don't provide the "application" option, symfony will take the database
configuration from the project `databases.yml` file.

The following task signatures have been changed accordingly:

 * `propel:build-all-load`
 * `propel:data-dump`
 * `propel:data-load`

>**Note**
>This is possible because `sfDatabaseManager` now takes a project configuration or an
application configuration. For the curious one, this works because
`sfDatabaseConfigHandler` now returns a static or a dynamic configuration based
on an array of configuration files (see the `execute()` and `evaluate()` methods).
