Upgrade from 1.1 to 1.2
=======================

This document describes the changes made in symfony 1.2 and what need
to be done to upgrade your symfony 1.1 projects.

>**CAUTION**
>symfony 1.2 is compatible with PHP 5.2.4 or later.
>It might also work with PHP 5.2.0 to 5.2.3 but there is no guarantee.

How to upgrade?
---------------

To upgrade a project:

  * If you don't use a SCM tool, please make a backup of your project.

  * Launch the `project:upgrade1.2` task from your project directory
    to perform an automatic upgrade:

        $ ./symfony project:upgrade1.2

    This task can be launched several times without any side effect. Each time
    you upgrade to a new symfony 1.2 beta / RC or the final symfony 1.2, you
    have to launch this task.

The remaining sections explain the main changes made in symfony 1.2.

Request
-------

The `path_info_array`, `path_info_key`, and `relative_url_root` settings have
been moved from `settings.yml` to `factories.yml` (in the `param` section of the
`request` factory configuration).

This change removes the dependency between `sfRequest` and `sfConfig`.

These three request options are now passed to the request constructor as a
fourth argument. The formats are also passed as an option,
instead of being passed as an attribute.

The request method constants from `sfRequest` values have changed from integers
to strings and the `sfRequest::NONE` method has been removed:

 **Constant** | **Old value** | **New value**
 ------------ | ------------- | -------------
 GET          | 2             | GET
 POST         | 4             | POST
 PUT          | 5             | PUT
 DELETE       | 6             | DELETE
 HEAD         | 7             | HEAD
 NONE         | 1             | -

The `getMethod()` and `getMethodName()` methods now returns the same value,
so `getMethodName()` is deprecated.

The `sfAction::getMethodNames()` and the corresponding code in
`sfValidationExecutionFilter` from `sfCompat10Plugin` have been removed.
This method was deprecated in 1.1 and was not really useable in 1.0.

You can now simulate `PUT` and `DELETE` requests from a browser by using the
`POST` method and adding a special `sf_method` parameter:

    [php]
    <form action="#" method="POST">
      <input type="hidden" name="sf_method" value="PUT" />

      <!-- // ... -->
    </form>

The `form_tag()` helper has been updated to automatically generate the hidden
tag for methods different form `GET` and `POST`. So, the opening `form` tag
from the code above can be generated by using the `form_tag()` helper like this:

    [php]
    <?php echo form_tag('#', array('method' => 'PUT')) ?>

Forms
-----

The new `sfForm::renderFormTag()` method generatess the opening
`form` tag for the current form. It also adds the `enctype`
attribute if the form needs to be multipart and adds a
hidden tag if the form method is not `GET` or `POST`:

    [php]
    <?php echo $form->renderFormTag('@article_update', array('method' => 'PUT')) ?>

The `sfFormPropel` class overrides `renderFormTag()` to automatically change
the HTTP method based on the related object: if the object is new, the method
will be `POST`, and if the object already exists, the method will be `PUT`.

Response
--------

There is a new setting for the `response` factory: `send_http_headers`.
This setting is `true` by default, except for the `test` environment where
the headers must not be sent by PHP (the same goal was achieved by using
the `sf_test` setting in symfony 1.1).

This change removes the dependency between `sfResponse` and `sfConfig`.

The response has a new method, `getCharset()`, which returns the current
charset for the response. This charset is automatically updated if
you change it by setting the content type.

The `getStylesheets()` and `getJavascripts()` methods can now return all the
stylesheets and javascripts ordered by position if you pass `sfWebResponse::ALL`
as their first argument:

    [php]
    $response = new sfWebResponse(new sfEventDispatcher());
    $response->addStylesheet('foo.css');
    $response->addStylesheet('bar.css', 'first');

    var_export($response->getStylesheets());

    // outputs
    array(
      'bar.css' => array(),
      'foo.css' => array(),
    )

The `sfWebResponse::ALL` is also now the default value for the position argument.
In symfony 1.1, as the default value is the empty string, the methods only return
the files registered for the default position by default, which is not very intuitive.

In symfony 1.1, you was able to get all the files by passing the `'ALL'` string
as the position, and this behavior is still available by passing
`sfWebResponse::RAW`:

    [php]
    var_export($response->getStylesheets(sfWebResponse::RAW));

    // outputs
    array(
      'first' =>
        array(
          'bar.css' => array (),
        ),
      '' =>
        array(
        'foo.css' => array(),
        ),
      'last' => array(),
    )

All the positions (first, '', and last) are now also available as constants:

    [php]
    sfWebResponse::FIRST  === 'first'
    sfWebResponse::MIDDLE === ''
    sfWebResponse::LAST   === 'last'

The `removeStylesheet()` and `removeJavascript()` methods now only take one argument,
the file to remove from the response. It will remove the file in all the available
positions. In symfony 1.1, they take the position as a second argument.

Prototype and Scriptaculous
---------------------------

symfony continues to decouple its bundled software. In 1.2 the bundled Prototype and 
Scriptaculous libraries and helper (`JavascriptHelper`) have been moved to a core-plugin.
Core plugins behave like real plugins but are shipped by symfony platform. This will make
the javscript and css files of the new `sfProtoculousPlugin` (the more or less inofficial 
name of the often featured duo) behave like real plugin assets. They will be now in 
`web/sfProtoculousPlugin` rather than in `web/sf` (as it has been in 1.0 and 1.1). The 
`prototype_web_dir` setting will also now point tot the new directory.

>**CAUTION**
>**Work in progress:** As plugins are normally installed via a task and this invokes the 
>creation of the symlink in the web directory this is required for core plugins as well.
>To do this manually you need to invoke:
>
> ``symfony plugin:configure-core``
>
> The target is that the project creation and upgrade task do this for you


Validators
----------

The `sfValidatorSchemaCompare` constant values have been changed. No change to
your code need to be done, but now, you can use nice shortcuts.
The following two examples are equivalent:

    [php]
    // symfony 1.1 and 1.2
    $v = new sfValidatorSchemaCompare('left', sfValidatorSchemaCompare::EQUAL, 'right');

    // symfony 1.2 only
    $v = new sfValidatorSchemaCompare('left', '==', 'right');

Tests
-----

### Cookies

Cookies are now extensively supported in the `sfBrowser` and `sfTestBrowser`
classes.

You can manage cookies between requests by using the `setCookie()`,
`removeCookie()`, and `clearCookies()` methods of the `sfBrowser` class:

    [php]
    $b->
      setCookie('foo', 'bar')->
      removeCookie('bar')->
      get('/')->
      // ...

      clearCookies()->
      get('/')->
      // ...

You can also test cookies with the `hasCookie()` and `isCookie()` methods of
the `sfTestBrowser` class:

    [php]
    $b->
      get('/')->
      hasCookie('foo')->
      hasCookie('foobar', false)->
      isCookie('foo', 'bar')->
      isCookie('foo', '/a/')->
      isCookie('foo', '/!z/')->

The `hasCookie()` method takes a Boolean as its second argument to be able to
test the fact that a cookie is not set.

The second argument of the `isCookie()` method behaves as the second argument
of the `checkElementResponse` method. It can be a string, a regular expression,
or a negative regular expression.

The browser class also automatically expires cookies as per the `expire` value
of each cookie.

### Links

When you simulate a click on a button or on a link, you give the name to the `click()`
method. But you don't have the possibility to differentiate two different links or buttons
with the same name.

As of symfony 1.2, the `click()` method takes a third argument to tell the position of
the link you want to click on the page:

    [php]
    $b->
      click('/', array(), 1)->
      // ...
    ;

By default, symfony clicks on the first link it finds in the page.

YAML
----

The YAML parser now supports full merge key (see http://yaml.org/type/merge.html
for more examples).

    [php]
    $yaml = new sfYamlParser();

    var_export($yaml->parse(<<<EOF
    default_param: &default_param
      datasource: propel
      phptype:    mysql
      hostspec:   localhost
      database:   db
      username:   user
      password:   pass

    param:
      <<: *default_param
      username:   myuser
      password:   mypass
    EOF
    ));

    // outputs
    array(
      'default_param' => array(
        'datasource' => 'propel',
        'phptype'    => 'mysql',
        'hostspec'   => 'localhost',
        'database'   => 'db',
        'username'   => 'user',
        'password'   => 'pass',
      )

      'param' => array(
        'datasource' => 'propel',
        'phptype'    => 'mysql',
        'hostspec'   => 'localhost',
        'database'   => 'db',
        'username'   => 'myuser',
        'password'   => 'mypass',
      )
    )

Actions
-------

By default, when you use the `redirectIf()` or `redirectUnless()` methods
in your actions, symfony automatically changes the response HTTP status
code to 302.

These two methods now have an additional optional argument to change this
default status code:

    [php]
    $this->redirectIf($condition, '@homepage', 301);
    $this->redirectUnless($condition, '@homepage', 301);

The `redirect()` method already have this feature.

sfParameterHolder
-----------------

The `has()` method of `sfParameterHolder` has been changed to be more
semantically correct.

It now returns `true` even if the value is `null`:

    [php]
    $ph = new sfParameterHolder();
    $ph->set('foo', 'bar');
    $ph->set('bar', null);

    $ph->has('foo') === true;
    $ph->has('bar') === true; // returns false under symfony 1.0 or 1.1

The `sfParameterHolder::has()` method is used by the `hasParameter()` and
`hasAttribute()` methods available for a large number of core classes.

Loggers
-------

symfony 1.2 comes with a new built-in logger: `sfVarLogger`. This logger class
logs all the messages as an array for later use. It's up to you to get the logs
and do something with them:

    [php]
    $log = new sfVarLogger();
    $log->log('foo');

    var_export($log->getLogs());

    // outputs
    array(
      0 => array(
        'priority'      => 6,
        'priority_name' => 'info',
        'time'          => 1219385295,
        'message'       => 'foo',
        'type'          => 'sfOther',
        'debug_stack'   => array()
      )
    )

Each log is an associative array with the following keys: `priority`, `priority_name`,
`time`, `message`, `type`, and `debug_stack`.

The `debug_stack` attribute is only set if you turns the `xdebug_logging` option to `true`.
It then contains the stack trace returned by xdebug as an array.

The `sfVarLogger` is also the base class for the `sfWebDebugLogger` class. So, the
`xdebugLogging` option of `sfWebDebugLogger` has been renamed to `xdebug_logging`.

Web Debug Toolbar
-----------------

The web debug toolbar is now customizable. The toolbar is composed of panels. A panel is
an object that extends `sfWebDebugPanel` and provides all the needed information to display
if on the toolbar.

By default, the following panels are automatically registered:

 *name*          | *class name*
 --------------- | -------------------------------
 symfony_version | `sfWebDebugPanelSymfonyVersion`
 cache           | `sfWebDebugPanelCache`
 config          | `sfWebDebugPanelConfig`
 logs            | `sfWebDebugPanelLogs`
 time            | `sfWebDebugPanelTimer`
 memory          | `sfWebDebugPanelMemory`
 db              | `sfWebDebugPanelPropel`

You can customize the web debug toolbar by listening to the `debug.web.load_panels` event.
The listener can then add new panels, remove existing ones, or even replace some.

The `sfWebDebugPanelLogs` panel filters the logs to be displayed by notifying the
`debug.web.filter_logs` event.
For example, the `sfWebDebugPanelPropel` and `sfWebDebugPanelTimer` connect to this event
to remove all Propel related logs and timer logs from the logs panel.

The total time displayed on the web debug toolbar is now computed with `$_SERVER['REQUEST_TIME']`
(we used to compute it with `sfConfig::get('sf_time_start')`, which does not exist anymore).
This means that the time displayed will be much larger than in symfony 1.0 and 1.1.

Browser
-------

The `sfBrowser` and `sfTestBrowser` classes have been refactored in four classes:

  * `sfBrowserBase`:        The base browser class. It knows nothing about symfony,
                            except classes from the symfony platform.

  * `sfBrowser`:            It inherits from `sfBrowserBase` and implements the
                            methods specific to symfony.

  * `sfTestFunctionalBase`: The base functional test class. It implements test
                            methods that are independant from symfony.

  * `sfTestFunctional`:     It inherits from `sfTestFunctionalBase` and implements
                            the test methods specific to symfony.

  * `sfTestBrowser`:        A BC class which is the same as the `sfTestFunctional`
                            class with a constructor signature compatible with symfony 1.1

The idea behind the refactor is that the `sfTestFunctional` class is a test class,
not a browser. So, it takes a browser and a test object as its arguments:

    [php]
    $testBrowser = new sfTestBrowser('localhost');

    $tester = new sfTestFunctional(new sfBrowser('localhost'), new lime_test());

The `sfTestFunctional` class acts as a proxy for the browser class which means
that all methods from the browser are accessible directly from the tester object.

This refactor must not introduce backward incompatibility with symfony 1.1.

Tasks
-----

Some CLI tasks takes an application name as an argument because they need to connect
to the database. We need an application because the configuration can be customized
on an application basis and all the symfony configuration system is based on the
application level.

For these tasks, this argument has been removed in favor of an optional "application"
option. If you don't provide the "application" option, symfony will take the database
configuration from the project `databases.yml` file.

The following task signatures have been changed accordingly:

 * `propel:build-all-load`
 * `propel:data-dump`
 * `propel:data-load`

>**Note**
>This is possible because `sfDatabaseManager` now takes a project configuration or an
application configuration. For the curious one, this works because
`sfDatabaseConfigHandler` now returns a static or a dynamic configuration based
on an array of configuration files (see the `execute()` and `evaluate()` methods).

The `propel:insert-sql` task removes all the data from the database.
As it destroys information, it now asks the user to confirm the execution of
the task. The same goes for the `propel:build-all` and `propel:build-all-load` tasks,
as they call the `propel:insert-sql` task.

If you want to use these tasks in a batch and want to avoid the confirmation question,
pass the `no-confirmation` option:

   $ php symfony propel:insert-sql --no-confirmation

The `sfTask` base class now provides three new methods to use in your tasks:

  * `logBlock()`:        Logs a message in a styled block
                         (default styles are: INFO, COMMENT, QUESTION, and ERROR)
  * `ask()`:             Asks a question to the user and returns the given answer
  * `askConfirmation()`: Asks a confirmation to the user and return true if the user
                         confirmed, false otherwise

The `propel:generate-crud` has been renamed to `propel:generate-module`. The old
task name is still available as an alias.

Routing
-------

The `sfPatternRouting` class now stores its routes as an array of `sfRoute`
objects instead of a flat associative array.

By default, symfony uses the built-in `sfRoute` object, but you can change
it by specifying a `class` entry in your `routing.yml` configuration file:

    [yml]
    foo_bar:
      url:   /foo/:bar
      class: myRoute
      param: { module: foo, action: bar }

All the routing logic is contained in the `sfRoute` class, which means you
can override the parsing and the generation logic with your own.

>**TIP**
>The `sfRoute` class is much more modular than the old `sfPatternRouting` class
>to allow easier customization of the default behavior. The "compilation" phase
>has been refactored into smaller methods, the code has been simplified,
>and it is based on a "real" tokenizer.

If you connect your routes with PHP code, you must now pass a `sfRoute` instance
as the second argument for the `connect()`, `preprendRoute()`, `appendRoute()`,
and `insertRouteBefore()` methods:

    [php]
    $route = new myRoute('/foo/:bar', array('module' => 'foo', 'action' => 'bar'));
    $routing->connect('foo_bar', $route);

The `sfRoute` constructor takes an array of options as its last argument to
allow the customization of each route. In the `routing.yml` configuration file,
use to `options` key:

    [yml]
    article:
      url:     /article/:id-:slug
      options: { segment_separators: [/, ., -] }

Symfony has another built-in route, `sfRequestRoute`, which can enforce the
HTTP method for your routes:

    [yml]
    article:
      url:          /article/:id
      requirements: { sf_method: get }
      class:        sfRequestRoute

This is made possible because the `parse()` method of `sfRouting` now takes a
context as a second argument. When the request calls the routing, it passes
the following context:

  * `method`:      The HTTP method name
  * `format`:      The request format
  * `host`:        The hostname
  * `is_secure`:   Whether the request was called with HTTPS or not
  * `request_uri`: The full request URI
  * `prefix`:      The prefix to add to each generated route

With the previous routing configuration, the `article` route will only match
requests with a `get` HTTP method. If you define several routes with the same
`url` but different method requirements, you can pass `sf_method` as a parameter
when you generate a route:

    [php]
    <?php echo link_to('Great article', '@article?id=1&sf_method=get')) ?>

The routing takes two new options:

  * `generate_shortest_url`:            Whether to generate the shortest URL
                                        possible
  * `extra_parameters_as_query_string`: Whether to generate extra parameters
                                        as a query string

By default, they are set to `false` in the default `factories.yml` configuration
file to keep backward compatibility with symfony 1.0 and 1.1.

You can also enable or disable these options on a route basis:

    [yml]
    articles:
      url:     /articles/:page
      param:   { module: article, action: list, page: 1 }
      options: { generate_shortest_url: true }

This route will generate the shortest URL possible. So, if you pass a `page`
of `1`, the generated URL will be `/articles`:

    [php]
    echo url_for('@articles?page=1');
    // /articles
    // would have been /articles/1 in symfony 1.1

    echo url_for('@articles?page=2');
    // /articles/2

    [yml]
    articles:
      url:     /articles
      options: { extra_parameters_as_query_string: true }

This route will accept extra parameters and add them as a query string:

    [php]
    echo url_for('@articles?page=1');
    // /articles?page=1
    // would not have matched the route in symfony 1.1

    echo url_for('@articles?page=2');
    // /articles?page=2

URL helpers
-----------

If you want to create a link to a resource that must be submitted with the
`POST`, `PUT`, or `DELETE` HTTP method, the `link_to()` helper can convert
a link to a form if you pass the `method` option:

    [php]
    <?php echo link_to('@article_delete?id=1', array('method' => 'delete')) ?>

The old `post` option is still valid but deprecated:

    [php]
    // is deprecated
    <?php echo link_to('@some_route', array('post' => true)) ?>

    // and equivalent to
    <?php echo link_to('@some_route', array('method' => 'post')) ?>
