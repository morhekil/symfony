How to make persistent sessions with cookies?
=============================================

Overview
--------

Symfony offers access to cookies via the `sfWebRequest` and `sfWebResponse` objects. It makes the use of cookies very easy, and persistent login becomes a piece of cake.

Cookie getter and setter
------------------------

A cookie is a string stored in the client's computer, written by a web application and readable only by the same application - or domain.

In symfony, the setter and getter for cookies are methods of different objects, but that makes sense. To get a cookie, you inspect the request that was sent to the server, thus using the `sfWebRequest` object. On the other hand, to set a cookie, you modify the response that will be sent to the user, thus using the `sfWebResponse` object. To manipulate cookies from within an action, use the following shorcuts:

    [php]
    // cookie getter
    $string = $this->getRequest()->getCookie('mycookie');
    
    // cookie setter
    $this->getResponse()->setCookie('mycookie', $value);
    
    // cookie setter with options
    $this->getResponse()->setCookie('mycookie', $value, $expire, $path, $domain, $secure);
    
The syntax of the `->setCookie()` method is the same as the one of the basic PHP `setcookie()` function (refer to the [PHP manual](http://www.php.net/setcookie) for more information). The main advantage of using the `sfWebResponse` method is that symfony logs cookies, and that you can keep on reading and modifying them until the response is actually sent.

>**Note**: If you want to manipulate cookies outside of an action, you will need to access the `Request` and `Answer` objects without shortcut:
>
>     $request  = sfContext::getInstance()->getRequest();
>     $response = sfContext::getInstance()->getResponse();
>

Persistent login
----------------

A good application of cookies (apart from basin session handling, which is completely transparent in symfony) is the persistent login functionality. Most of the login forms offer a "remember me" check-box which, when clicked, allows the user to bypass the login process for further sessions.

### Basic login

Let's imagine an application where all the modules are secure except the `security` module. The `settings.yml` is configured to handle the request of unlogged users to the `security/index` action:

    all:
      .settings:
        login_module:           security
        login_action:           index

The model has a `User` class with at least a `login` and a `password` column. The `indexSuccess.php` template shows a login form (without "remember me" checkbox for now), and handles the submission to the `security/login` action:

    [php]
    public function executeIndex()
    {
    }
    
    public function executeLogin()
    {
      // check if the user exists
      $c = new Criteria();
      $c->add(UserPeer::LOGIN, $this->getRequestParameter('login'));
      $user = UserPeer::doSelectOne($c);
      if ($user)
      {
        // check if the password is correct
        if ($this->getRequestParameter('password') == $user->getPassword())
        {
          // sign in
          $this->getContext()->getUser()->signIn();
          // proceed to home page
          return $this->redirect('main/index');
        }
        else
        {
          $this->getRequest()->setError('password', 'wrong password');
        }
      }
      else
      {
        $this->getRequest()->setError('email', 'this user does not exist');
      }
    
      // an error was found
      return $this->forward('security', 'index');
    }

>**Note**: The verification of the login and password could also take place in a custom validator for a better model logic, as explained in the [askeet tutorial](http://www.symfony-project.com/askeet/6).

Now, let's have a look at this `->signIn()` method in the `myUser` class:

    [php]
    class myUser extends sfBasicSecurityUser
    {
      public function signIn()
      {
        $this->setAuthenticated(true);
      }
    
      public function signOut()
      {
        $this->setAuthenticated(false);
      }
    }

That's all very basic. But it works fine, as long as you ask the user to login at every session.

### Persistent login

To allow a persistent login, the server has to store some information in the client's computer (here comes the cookie) proving who the user is and that he/she successfully logged in in the past. Of course, for security reasons, the password cannot be the data to store (and, by the way, that would be incompatible with the [sha1 hash](http://en.wikipedia.org/wiki/SHA_hash_functions) password storage method described in the [askeet tutorial](http://www.symfony-project.com/askeet/6)). So what to store then? Whatever the cookie stores, it has to be the same piece of data as in the database, so that the comparison of the two proves the authentication. So, to avoid risks, a random string will be stored and regenerated every 15 days (the lifetime that will be given to the cookie).

Add a new `remember_key` column to the `User` table (and rebuild the model). This is where a random key, stored both in the clients computer and in the database, will be stored. The remember key has to be set when a user asks to be remembered, so change the sign-in line in the `login` action by:

    [php]
    // sign in
    $remember = $this->getRequestParameter('remember_me');
    $this->getContext()->getUser()->signIn($user, $remember);

Don't forget to add a `remember_me` checkbox to the `modules/security/templates/indexSuccess.php` form for this to work.

The `->signIn()` method of the `myUser` class has to be modified to set the remember key both in the database and in the cookie:

    [php]
    public function signIn($user, $remember = false)
    {
      $this->setAuthenticated(true);

      if ($remember)
      {
        // determine a random key
        if (!$user->getRememberKey())
        {
          $rememberKey = myTools::generate_random_key();

          // save the key to the User table
          $user->setRememberKey($rememberKey);
          $user->save();
        }
                
        // save the key to the cookie
        $value = base64_encode(serialize(array($user->getRememberKey(), $user->getLogin())));
        sfContext::getInstance()->getResponse()->setCookie('MyWebSite', $value, time()+60*60*24*15, '/');
      }
    }

The `generate_random_key()` method is left to your sagacity. Now, you just need to change the `security/index` action a little bit:

    [php]
    public function executeIndex()
    {
      if ($this->getRequest()->getCookie('MyWebSite'))
      {
        $value = unserialize(base64_decode($this->getRequest()->getCookie('MyWebSite')));
        $c = new Criteria();
        $c->add(UserPeer::REMEMBER_KEY, $value[0]);
        $c->add(UserPeer::LOGIN, $value[1]);
        $user = UserPeer::doSelectOne($c);
        if ($user)
        {
          // sign in
          $this->getContext()->getUser()->signIn($user);
          // proceed to home page
          return $this->redirect('main/index');
        }
      }
    }

This is where the cookie is read. And that's it.

>**Note**: If some pages of your website are accessible without authentication, then the `security/index` action is not the first action to be executed at all times. In order to automatically log users in that case, you will probably prefer to add a new `rememberFilter` in your application `lib/` directory instead of doing the cookie check in one action only:
>
     [php]
     class rememberFilter extends sfFilter
     {
       public function execute ($filterChain)
       {
         // execute this filter only once
         if ($this->isFirstCall())
         {
           $request = $this->getContext()->getRequest();
           if ($request->getCookie('MyWebSite'))
           {
             $value = unserialize(base64_decode($this->getRequest()->getCookie('MyWebSite')));
             $c = new Criteria();
             $c->add(UserPeer::REMEMBER_KEY, $value[0]);
             $c->add(UserPeer::LOGIN, $value[1]);
             $user = UserPeer::doSelectOne($c);
             if ($user)
             {
               // sign in
               $this->getContext()->getUser()->signIn($user);
             }
           }
         } 
         // execute next filter
         $filterChain->execute();
       }
     }
>
>Of course, you will have to declare this filter in your application `filters.yml` configuration file:
>
>      rememberFilter:
>        class: rememberFilter
>

One last thing: If the user logs out, don't forget to remove the cookie!

    [php]
    public function signOut()
    {
      $this->setAuthenticated(false);
      sfContext::getInstance()->getResponse()->setCookie('MyWebSite', '', time() - 3600, '/');
    }