Templating in practice : Link helpers
=====================================

Overview
--------

One of the common needs in templates is the automation of the URL generation, and the inclusion of local files regardless of the file structure. The link and image helpers, for instance, naturally replace the `<a>` and `<img>` tags and do all the tedious job for you. Their use is compulsory to enable routing and relative links affected by configuration.

Introduction
------------

The way to call an action with an URL has already been explained: put the module and action names after the front controller, then the parameters of the action either in the classic "GET" style or between `/`:

    http://myapp.example.com/index.php/article/read?title=Finance_in_France
    // is equivalent to
    http:/myapp.example.com/index.php/article/read/title/Finance_in_France
    
    // additionally, the following works if the routing is deactivated
    http://myapp.example.com/index.php?module=article&action=read&title=Finance_in_France

Imagine that you want to add a hyperlink to this page in a template. In PHP, you could be tempted to write:

    <a href="/index.php/article/read?title=Finance_in_France">Finance in France</a>

This is a bad idea, because: 

* by writing `index.php`, you point to a particular environment (in this case, the production environment). All links must be environment-independent if you don't want to accidentally change environment while navigating
* if you later decide to change the **routing** policy (you can learn more about this feature in the [routing chapter](routing.txt) chapter), and to display another format of URL, you would have to parse all of your template files and replace by hand the URLs already entered to URLs like:

            <a href="/index.php/articles/europe/france/finance.html">Finance in France</a>

If you ever built a website, you know that these problems occur all the time.

The link helpers are there for you. They allow symfony to create URLs and hyperlinks to actions compliant to the routing policy, without any dependence to the environment.

Link helpers
------------

### Syntax

The `url_for()` helper returns an URL, the `link_to()` helper returns a hyperlink. You may never use the first one, but you will use `link_to()` a lot.

    <?= url_for('article/read?title=Finance_in_France') ?>
    // will generate in HTML
    http://myapp.example.com/index.php/article/read/title/Finance_in_France
    
    <?= link_to('interesting article', 'article/read?title=Finance_in_France') ?>
    // will generate in HTML
    <a href="http://myapp.example.com/index.php/article/read/title/Finance_in_France" title="interesting article">interesting article</a>
    
Notice that the default routing rules transform all the `?`, `=` and `&` characters into by `/`. Also note that the `link_to()` helper gives a bonus `title` attribute for the `<a>` tag, based on the content of the tag that is provided.

Enter in the link helper just the same URL as you would have written in a `<a href="...` tag, and it will transform it for you into a "smart" link according to the current routing policy. And when the customer decides to change some of the rules, just modify the `routing.yml` configuration file and the generated URL can now look like:

    <a href="http://myapp.example.com/articles/europe/france/finance.html" title="interesting article">interesting article</a>

Link helpers are the key to a double way routing. Interpreting URLs is not a big deal, but generating them requires that all hyperlink tags pass by the same filter. That's why these helpers are compulsory as soon as you may use the routing feature. Make sure you take a look at the [routing chapter](routing.txt) to see how to change the shape of URLs, get rid of the controller name or add a '.html' to the generated URLs for more efficient caching and indexing.

### Using the rule instead of the module/action

If you had a look at the [routing chapter](routing.txt), you saw that the routing is defined by rules. The link helpers accept a rule name instead of a pair `module/action` if a `@` is written before. For instance, if the `routing.yml` file contains the rule:

    cart:
      url: /shopping_cart
      param: { module: shoppingCart, action: index }

Then you can write

    <?= link_to('go to shopping cart', '@cart') ?>

instead of

    <?= link_to('go to shopping cart', 'shoppingCart/index') ?>
    
There are pros and cons to this trick:

* the routing is done much faster, since symfony doesn't have to browse all the rules to find the one that matches the link. In a page with a great number of routed hyperlinks, the boost will be noticeable if you use rules instead of `module/action`
* using the rule helps to abstract the logic behind an action. If the need to plug another action behind a given URL arises, then only the `routing.yml` file will need to be changed - all the `link_to()` calls will still work without intervention
* the logic of the call is more apparent with a rule name. Even if your modules and actions have explicit names, it is often better to call "display_article_by_title" than "article/display"

On the other hand,

* if you write rules in your `link_to()`, you can not deactivate the routing anymore.
* it becomes less evident to debug an application since you always need to refer to the `routing.yml` file to discover which action is called by a link.

The best choice depends on the project. In the long run, it's up to you.

### Fake GET

Sometimes, web developers tend to use GET requests to actually do a POST. For instance, consider the following URL:

    http://myapp.example.com/index.php/shopping_cart/add?id=100

This request will change the data contained in the application, so it should be considered as a POST. 

This URL can be bookmarked, cached and indexed by search engines. Imagine all the nasty things that might happen to the users or to the statistics of a website using this technique. In addition, the same result can be easily achieved with forms or javascript.

Well, there is one more bad consequence: the default symfony routing rules will transform this kind of URL into

    http://myapp.example.com/index.php/shopping_cart/add/id/100

This looks like a completely static page while obviously, the page behind it is dynamic. So this will create even more confusion and risks of errors. All in all, there is no good reason to use that kind of URL. 

Mailto Helper
-------------

The reason why symfony ships a `mail_to()` helper is that nowadays, email farming robots prowl about the web, and you can't display an email address on a website without becoming a spam victim within days.

This helper takes two parameters : the actual email address, and a secure flag. If the flag is set to `false`, the email address is written non-crypted:

    <?= mail_to('myaddress@mydomain.com', false) ?>
    // will generate in HTML
    <a href="mailto:myaddress@mydomain.com'>myaddress@mydomain.com</a>

If the flag is set to `true`, and this is the default behavior, the displayed and pointed addresses are processed by a random decimal and hexadecimal entity encoder. This will probably not stop all address-harvesting spambots, but it will keep most of them away. Future versions of this helper will probably evolve as the harvesting techniques become more accurate.

    <?= mail_to('myaddress@mydomain.com') ?>
    // will generate in HTML something like
    <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#109;&#x79;&#x61;&#x64;&#x64;re&#x73;&#115;&#64;m&#121;&#100;&#111;&#109;&#x61;&#105;&#x6e;.&#99;&#111;&#x6d;">myaddress@mydomain.com</a>

Image helper
------------

Considering that all your HTML pages are handled by actions, the `href` attribute is no worry anymore. But what about all those tags having a `src` attribute ? Symfony has image and javascript helpers that are faster to write and to most of the job themselves. 

In addition, future versions will support configuration for the default location of media files. This may prove helpful if you decided suddenly to host all of your project media files (css, js, pdf, jpg, gif, etc.) in a new server to increase performance.

To create an `<img>` tag:

    <?= image_tag('test') ?>
    // will generate in HTML
    <img href="/images/test.png" alt="Test" />

By default, the image `test.png` will be looked for in the `/images/` directory of the web server (which is the `myproject/myapp/web/image/` directory of your file structure, unless you customized it). 

If you need to change the default file type or the default location, you can pass a more defined URL:

    <?= image_tag('test.gif') ?>
    // will generate in HTML
    <img href="/images/test.gif" alt="Test" />
    
    <?= image_tag('/my_images/test.gif') ?>
    // will generate in HTML
    <img href="/my_images/test.gif" alt="Test" />

You can add a second argument to specify additional HTML attributes; this argument must be an array. 

    <?= image_tag('/my_images/test.gif', array('class' => 'shortImage')) ?>
    // will generate in HTML
    <img href="/my_images/test.gif" alt="Test" class="shortImage"/>

Don't bother to specify a `alt` attribute if your media file has an explicit name, since symfony will determine it for you.

To fix the size of an image, use the attribute `size`:

    <?= image_tag('/my_images/test.gif', array('size' => '100x20')) ?>
    // will generate in HTML
    <img href="/my_images/test.gif" alt="Test" width="100" height="20"/>

To keep the code readable and let you write templates fast, the options argument can use an abbreviated string syntax:

    <?= image_tag('/my_images/test.gif', 'size=100x20 alt=My new car class=shortImage onclick=showNextImage(); ') ?>
    // is the same as
    <?= image_tag('/my_images/test.gif', array('size' => '100x20', 'alt' => 'My new car', 'class' => 'shortImage' , 'onclick' => 'showNextImage();') ) ?>
    // will generate in HTML
    <img href="/my_images/test.gif" alt="My new car" width="100" height="20" class="shortImage" onclick="showNextImage();" />

Javascript helper
-----------------

To link to javascript files, you can omit the path and the suffix: 

    <?= javascript_tag('myscript') ?>
    // will generate in HTML
    <script language="javascript" type="text/javascript" src="/js/myscript.js">

Once again, the default location can be overridden in a function call for punctual needs, or redefined for the whole site in the configuration files for major changes.

If you read the whole documentation, you will see that symfony gives you three different ways to require an additional javascript file. You should use them with this order of preference:

* parameter definition in the `view.yml` file: most of the time, the best solution
* `addJavascript()` function call from the action: when the name of the files to include depend on calculations made in the action
* `javascript_tag` helpers in the template: to include a javascript file at a given position inside a template and not in the head.

The last solution is rarely good; if you need it, check whether your code needs some refactoring (for instance write a javascript function call in the code and require the script inclusion in the head). However, you sometime don't have the choice, for instance if you have to include traffic measure scripts at the end of your pages.

>**Note**: you may be looking for a `stylesheet_tag()` helper, but there is none. If you need to include a custom stylesheet, you should not do it in the template but rather in the view or in the action, as described in the [view configuration chapter](templating_configuration.txt).