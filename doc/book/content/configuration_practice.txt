Configuration in practice
=========================

Overview
--------

The configuration can be defined for several levels : project, application, module. It can also be defined in several environments : development, test, production, and any additional environment needed. By modifying YAML files, you get the power of configuration at the tip of your fingers.

Environment-dependent configuration files will be identified with a star `*` in this documentation .

Introduction
------------

The symfony configuration system is inspired by the way [Mojavi][3] handles configuration. Although not appreciated by everybody, this system is extremely powerful.

Configuration is distributed into files, by subject. The files contain parameter definitions, or settings.

The parameter can be set according to a cascade of definitions : for instance, a given parameter can be defined at the project level, specialized at the application level, and specialized again at the module level. But the cascade is also valid for environments : a parameter definition in a named environment has precedence over a parameter definition for all environments, which has precedence over a definition in the default configuration.

Project configuration
---------------------

There are a few project configuration files by default. Here are the files that can be found in the `myproject/config/` directory:

* `config.php`: can hold general project configuration. If you add some `define` statements in this file, the constants will be accessible from every application of the project. This file is empty by default.
* `properties.ini`: holds a few parameters used by the pakefile (including the project name)
* `rsync_exclude.txt`: this file specifies which directories have to be excluded from the synchronization between environments. The default content should illustrate well its interest:

        stats
        .svn
        web/uploads
        cache
        log
        web/index.php
        config

* `apache.conf`: this file is not really a configuration file, since it is not used by the project. It is given as an example of an Apache configuration for a typical symfony project.
* `schema.xml` and `propel.ini` are data access configuration files used by Propel. They are automatically generated to plug the Propel libraries with the symfony classes and the data of your project, so you should probably not need to modify them. If you don't use Propel, these files are not needed.

So until now, you probably doubt the great efficiency of the YAML format in symfony since none of the project configuration files use it. But there is a good reason to that: these files are used by external components or need to be processed even before any YAML parsing program can be loaded to the framework. The real candy actually starts with the application configuration.

Application configuration
-------------------------

The main part of the configuration is the application configuration. The files located in `myproject/myapp/config/` will be briefly described here before a deeper look at how to modify them.

* `*app.yml`: this file should contain the application-specific configuration, i.e. global variables that don't really need to be stored in a database. VAT rates, shipping fares, emails are often stored in this file. It is empty by default.
* `config.php`: this file bootstraps the application, which means that it does all the very basic initializations to allow the application to start. It normally includes the project configuration (`myproject/config/config.php`), defines the directories layout (by inclusion of the `constants.php` file), defines the include path used to look for libraries, loads the necessary symfony classes, and includes some of the parsed .yml files of the application configuration (the others are loaded on demand). It is in PHP rather than YAML because the YAML interpreter isn't loaded when `config.php` is processed. 
* `*factories.yml`: the framework uses some classes to do the job; this file can force the use of alternate classes to manage the session, the actions, the front web controller... You shouldn't need to change this one, as you will see a little further. _see more below_
* `filters.yml`: symfony allows the execution of filters before actions. For instance, the Security filter is configured by default to check credentials for restricted actions. If you need to add a custom filter, for instance to calculate the time to execute an action, that's the file that you need to modify.
* `*logging.yml`: define which degree of log has to be recorded, to help you supervise and debug your application. See below for more details. _see more below_
* `*orm.yml`: this is where you define the access and the connection settings to the database (host, login, password, database name). _see more below_
* `routing.yml`: the routing rules, that allow transforming unreadable and unbookmarkable URLs into "smart" and explicit ones, are stored in this file. For new applications, a few default rules exist. To learn more about the use of this file, see the [Routing chapter](routing.txt).
* `*settings.yml`: the main settings of a symfony application are defined in this files. There you can specify is your application has internationalization, and if yes, what is its default language. You can define the request timeout, activate or deactivate the cache or the routing. If you need to shut off completely the application, a single change in this file will suffice, and that's another good proof of the interest of using a single front web controller. _see more below_
* `*tidy.yml`: if the use of [HTML Tidy][1] is activated in the `settings.yml`, then you can modify the options of this utility that alters the outputted HTML code to, for instance, re-indent the tags properly, or remove comments, or collapse all spaces and carriage returns to save bandwidth, or to correct missing closing tags if you have absentminded developers.
* `view.yml`: the structure of the default View (name of the layout, title and metas, default .js and .css files to be included, name of the included slots, etc.) is set in this file, that can be overridden for each module. It also defines the default value of the `meta` and `title` tags. The [View configuration chapter](templating_configuration.txt) explains its structure.

A second set of configuration files is in the symfony installation directory; the settings defined there are default settings that don't often need to be modified, or that are global to all projects. However, if you need to modify them, just copy the required file from the `symfony/config` directory to your `myproject/myapp/config/` directory. The settings defined in an application always have priority.

* `autoload.yml`: in this file, class names are bound to file names. For classes that are located in the `myproject/lib/`, `myproject/lib/model` and `myproject/myapp/lib/` directories, this exempts you from requiring them in your code : when the PHP parser meets a `New myclass` statement, it looks for a path to this 'myclass' file in the `autoload.yml`, loads the required library and include it automatically. This means that you don't need to require libraries at the head of your classes if they may not be used in every case: just let the framework do the job for you, and it will load only the very necessary classes, just in time.
* `constants.php`: this file defines the directory layouts, the directory separator, and everything that the framework needs to find your actions (normally in `actions`), your modules (normally in `modules`), your libraries (normally in `lib`), etc. You will probably need to modify this file if you develop an application for a client who already has a defined directory structure and who is not willing to change it to comply with the symfony logic (how would that be possible ?). _see more below_
* `core_compile.yml` and `bootstrap_compile.yml` are lists of classes to be included to start an application (in `bootstrap_compile.yml`) and to process a request (in `core_compile.yml`). These classes are actually concatenated into an optimized PHP file without comments, which will accelerate the execution by minimizing the file access operations (1 file is loaded instead of more than 40 for each request). This is especially useful if you don't use a PHP accelerator.
* `config_handlers.yml`: do you remember handlers ? This is where you can add or modify the handlers used to process each configuration file, for instance to use nasty INI or XML files instead of nice YAML files. Each configuration file having a handler class definition, you will find the customization quite clear.
* `php.yml`: checks that the variables of the `php.ini` file are properly defined, and allows you to override them if necessary. _see more below_

### General settings

The `settings.yml` file, which is environment dependent, contains the main application configuration. Here is the beginning of its default content:

    prod:
    
    dev:
      .settings:
        # E_ALL | E_STRICT = 4095
        error_reporting:        4095
        web_debug:              on
        cache:                  off
        stats:                  off
        no_script_name:         off
    
    test:
      .settings:
        cache:                  off
        stats:                  off
        web_debug:              off
    
    all:
    ;  .actions:
    ;    default_module:         default
    ;    default_action:         index
    ;    
    ;    error_404_module:       default
    ;    error_404_action:       error404
    ;    
    ;    login_module:           default
    ;    login_action:           login
    ;    
    ;    module_disabled_module: default
    ;    module_disabled_action: disabled
    ;    
    ;    secure_module:          default
    ;    secure_action:          secure
    ;    
    ;    unavailable_module:     default
    ;    unavailable_action:     unavailable
    ;
    ;  .settings:
    ;    available:              on
    ;    module_accessor:        module
    ;    action_accessor:        action
    ;    content_type:           html
    ...

First of all, you may notice that most of the configuration is inherited from the `default` definition : the statements starting with a `;` in the configuration for `all` environments are comments. This means that, for those parameters, the default configuration is used instead. If you need to override it, just decomment the line and modify the value.

The parameters defined in the `.action` category define the modules and actions to be used in certain situations. In particular:

* `default_*`: specifies which action of which module has to be called when nothing is passed. This is especially useful to set the home page action of your website (the one that will be called with the relative URL '/')
* `error_404_*`: the default module/action to be called when a 404 error (page not found) occurs is `default/error404`. This action is not explicit in a new application, but you can override it or choose a completely different module/action
* `login_*`: when a page requesting credentials will be accessed by an unidentified user, he/she will be automatically redirected to a login page. This parameter defines the module/action to use for that purpose.

A few clues about of some of the `.settings` parameters will also be useful:
    
* `available`: switches on (or off) the whole application
* `use_database`: for a website that doesn't need a database, this parameter is set to `off` (its default value)
* `use_security`: required for websites that have restricted areas, authentication and credentials (see the [chapter about security](security.txt) for more details)
* `compressed`: activates the HTML compression to decrease the bandwidth
* `tidy`: activates the use of [HTML Tidy][1]
* `is_i18n`: needs to be set to `on` if the site is published in several languages
* `default_culture`: specifies the default parameter used to format dates, numbers, currencies (`en` in the default configuration)
* `web_debug`: activation of the web debug frame, a tool that gives access to debug info on every page. The quantity of logged information is related to the entries of the `logging.yml` file, and needs the `SF_DEBUG` constant to be set to `true` in the front controller.
* `cache`: activates the cache feature to speed up page generation by recording chunks of compiled code
* `routing`: activates the routing feature to transform the outputted URLs and allow "smart" URLs to be interpreted. See more in the [routing chapter](routing.txt).
* `stats`: activates the recording of applicative statistics

Remember that each one of these settings is accessible from inside the PHP code via a constant; the constant name if the upper-cased parameter name prefixed with `SF_`. For instance, if you want the value of the `cache` parameter, you just need to call the constant `SF_CACHE`. 

### Database settings

If you need to use data stored in a database in your application, you first need to set the `use_database` setting of the `settings.yml` filer to `on`. Then, you can configure the access to your database (s) by entering data in the `orm.yml` file.

    all:
      adapter:  mysql
      host:     localhost
      database: mydatabase
      username: root
      password: 

The names of the parameters are pretty explicit, the most important being the `database` name. To learn more about data binding and the access to a database, go to the [data access](model.txt) chapter.

>**Note**: an additional database configuration file, the `database.yml` file, is used to keep compatibility between symfony and [Mojavi][2]. It is necessary to modify it.

### File structure settings

There is no `constants.php` file in a default application configuration directory. This means that if you need to change the file structure of your application, you have to copy the default `constants.php` file from the symfony installation directory into your `myproject/myapp/config/` directory and modify the values.

Every path to a key directory is determined with a constant ending with `_DIR`. Here is an extract of the standard configuration file:

    [php]
    // root directory structure
    define('SF_CACHE_DIR_NAME', 'cache');
    define('SF_LOG_DIR_NAME', 'log');
    define('SF_LIB_DIR_NAME', 'lib');
    define('SF_MODEL_DIR_NAME', 'model');
    define('SF_WEB_DIR_NAME', 'web');
    define('SF_DATA_DIR_NAME', 'data');
    
    // global directory structure
    define('SF_APP_DIR', SF_ROOT_DIR.DS.SF_APP);
    define('SF_MODEL_DIR', SF_ROOT_DIR.DS.SF_MODEL_DIR_NAME);
    define('SF_LIB_DIR', SF_ROOT_DIR.DS.SF_LIB_DIR_NAME);
    define('SF_VENDOR_LIB_DIR', SF_LIB_DIR.DS.'vendor');
    define('SF_WEB_DIR', SF_ROOT_DIR.DS.SF_WEB_DIR_NAME);
    define('SF_UPLOAD_DIR', SF_WEB_DIR.DS.'uploads');
    define('SF_BASE_CACHE_DIR', SF_ROOT_DIR.DS.SF_CACHE_DIR_NAME.DS.SF_APP);
    define('SF_CACHE_DIR', SF_BASE_CACHE_DIR.DS.SF_ENVIRONMENT);
    define('SF_LOG_DIR', SF_ROOT_DIR.DS.SF_LOG_DIR_NAME);
    define('SF_DATA_DIR', SF_ROOT_DIR.DS.SF_DATA_DIR_NAME);
    
    // SF_APP_DIR sub-directories names
    define('SF_APP_CONFIG_DIR_NAME', 'config');
    define('SF_APP_LIB_DIR_NAME', 'lib');
    define('SF_APP_MODULE_DIR_NAME', 'modules');
    define('SF_APP_TEMPLATE_DIR_NAME', 'templates');
    
    // SF_APP_DIR directory structure
    define('SF_APP_CONFIG_DIR', SF_APP_DIR.DS.SF_APP_CONFIG_DIR_NAME);
    define('SF_APP_LIB_DIR', SF_APP_DIR.DS.SF_APP_LIB_DIR_NAME);
    define('SF_APP_MODULE_DIR', SF_APP_DIR.DS.SF_APP_MODULE_DIR_NAME);
    define('SF_APP_TEMPLATE_DIR', SF_APP_DIR.DS.SF_APP_TEMPLATE_DIR_NAME);

To learn more about the default tree structure, consult the [file structure chapter](file_structure.txt).

### Logging settings

Symfony offers two ways to watch the log messages. 

Classically, the logs are output to files. Symfony stores message logs in files according to the application and the environment. For instance, in the `myproject/log/` directory, you will probably find two files:

    myapp_dev.log
    myapp_prod.log

Don't forget to periodically rotate these files, since symfony will not do it automatically.

If the `web_debug` function is set to on in your application (in `settings.yml`), the logs of each request are also available in the browser, in a special layer that appears on the right of the screen. Note that this option is activated by default in the development environment. 

The `logging.yml` file defines the log level to be output. By default, all levels are included (from alerts to unrecoverable errors). In the production environment, only the errors are logged.

    prod:
      level:    err
    
    dev:
      
    test:
    
    all:
    ;  active:  on
    ;  level:   debug

You can add your custom logging settings in this file, for instance if you need to monitor the input and output of an external API. You should definitely include there the I/O of requests to a payment API:

    prod:
      payment:  on

### Factories settings

Symfony uses classes such as sfFrontWebController, sfUser, sfRequest, sfShoppingCart that are part of the framework. In the `myproject/myapp/lib/` directory, you will find some files defining classes called myFrontWebController, myUser, myRequest, myShoppingCart, etc. They all simply inherit of the 'sf-' classes, and this allows you to specialize them. Symfony knows it needs to use these classes instead of the 'sf-' ones because of the configuration written in the `factories.yml` file:

    ...
    all:
    ;  controller:
    ;    class: myFrontWebController
    ;
    ;  request:
    ;    class: myWebRequest
    ;
    ;  user:
    ;    class: myUser
    ...

This means that you already have a prebuilt mechanism to change the **factories** of symfony, the big classes that run behind the curtain, by adding or inheriting methods to the 'my-' classes.

But if you want to use completely different factories, well, you can. Just modify the `factories.yml` entries to point to your custom files. 

### Front controller configuration

The very first application configuration is actually found in the front controller. Take a look at this default `web/index.php`:

    [php]
    <?php
    
    define('SF_ROOT_DIR', dirname(__FILE__).'/..');
    define('SF_APP', 'fo');
    define('SF_ENVIRONMENT', 'prod');
    define('SF_DEBUG', true);
    
    require_once SF_ROOT_DIR.DIRECTORY_SEPARATOR.SF_APP.DIRECTORY_SEPARATOR.'webapp'.DIRECTORY_SEPARATOR.'config.php';

    Controller::newInstance('sfFrontWebController')->dispatch();
    
    ?>

After defining the name of the application (`fo`) and the environment (`prod`), the general configuration file is called before the dispatching. So a few useful constants are defined here:

* `SF_ROOT_DIR`: project root path (normally, to be let to the defaults value `dirname(__FILE__).'/..' `)
* `SF_APP`: application name in the project
* `SF_ENVIRONMENT`: environment name (`prod`, `dev` or any other project-specific environment)
* `SF_DEBUG`: activation of the debug mode

### PHP configuration

The `php.yml` file modifies the php configuration to have a php environment compatible with the rules and the best practices used by symfony. Here is the default `php.yml`:

    set:
      magic_quotes_runtime: off
      log_errors:           on
      arg_separator.output: \&amp;
    
    check:
      magic_quotes_gpc:     off
      register_globals:     off

The variables defined under the `set` category are modified (despite how they were defined in the `php.ini`); the variables defined under the `check` category cannot be modified on the fly, so their values are checked and an exception raised if your current configuration doesn't match these criterias.

For instance, the default `php.yml` sets the `log_errors` to `on` so that you can trace errors in symfony projects. It also recommends the `register_globals` to be set to `off` to avoid security breaches.

If you need to use another value for these parameters, copy the default `php.yml` in your application `config` directory, and change the values to be set or checked. Alternatively, you can delete the lines that are not compatible with your environment in the application copy of the file.

### Handlers and additional configuration files

If you need a completely specific configuration file for your application, create both a new configuration file and a handler to decode it, as described in the [configuration handler chapter](sfConfigHandler.txt).

Module configuration
--------------------

By default, a module has no specific configuration. But, according to your needs, you can override existing configuration for a given module, or add new parameters restricted to this module.

As you may expect, module configuration files have to be located in a `myproject/myapp/modules/mymodule/config/` directory. They are:

* `app.yml`: custom parameters specific for a module
* `view.yml`: configuration for the views associated to the actions of a module
* `security.yml`: access restrictions for actions
* `generator.yml`: to create a data access interface (useful for back-office generation)
* data validation files: although located in the `validate/` directory instead of the `config/` one, the YAML data validation files, used to control the data entered in forms, are also specific to a module

Most module configuration files give the ability to define parameters for all the views or all the actions of a module, or for a subset of them.

### Custom parameters

If you need to override constants defined in the application `app.yml`, just create a new `app.yml` file here and assign specific values for you module. 

For instance, if the `notax` module is a duty-free shop where the VAT is reduced to zero, create a `app.yml` file in your `myproject/myapp/modules/notax/config/` directory with the following content:

    all:
      .general:
        tax:               0

But maybe you need a completely specific configuration file. In that case, as for custom app configuration, create a `myconfig.yml` file together with a `config_handlers.yml` file to handle its data (read the [configuration handler chapter](sfConfigHandler.txt) for more information).

### View

The interface components for a given module, and specifically for views of this module, can be customized by adding a `view.yml` file.

Here is an example module view configuration file:

    indexSuccess:
      javascripts:  [myinteraction]

    indexError:
      layout:       error
      stylesheets:  [error]
    
    listSuccess:  
      template:     listtemplate
      slots:
        breadcrumb: []
        
    all:
      layout:       mylayout
      slots:
        navigation: [bar, navigation]
        breadcrumb: [bar, breadcrumb]

The default layout for all the actions of this module is set to `mylayout.php` (as opposed to the default layout for the whole application, called `layout.php`). The `navigation` and `breadcrumb` slots are defined for all the actions of the module, except for the action `list` where the `breadcrumb` slot is suppressed. For this action, the template to be used will not be `listSucess.php` but `listtemplate.php`. If the result of the `index` action is `sfView::ERROR`, the template `indexError.php` will be integrated into the `error.php` layout, including a special `error.css` stylesheet. In addition, the `index` action requires a special javascript called `myinteraction.js` to be included in the page header so that the template can work correctly.

As this file also exists at the application level, adding it at the module level allows you to override the application-wide view parameters at the module level. 

Refer to the chapter describing the [view configuration](templating_configuration.txt) to learn more about this feature.

### Security

To restrict access to an action to a subset of authenticated users having special credentials, you will use a special module configuration file called `security.yml`. 

Here is an example module security configuration file:

    update:
      is_secure:  on
    
    save:
      is_secure:  on
    
    orders:
      is_secure:  on
    
    all:
      is_secure:  off
      credential: customer

The `update`, `save` and `orders` actions of this module will only work for authenticated users with the `customer` credential.

To learn more about security and the way to set credentials, report to the [related chapter](security.txt).

### Generator

One commonly used module configuration file is the `generator.yml` file. When you setup a 'Create Read Update Delete' (CRUD) basic layout for a data object, the module created will have a `generator.yml` file that you can modify. Read more about CRUDs and scaffolding in the [generator chapter](generator.txt).

### Form validation

The last usual module configuration file concerns form validation and is not located in the `myproject/myapp/modules/mymodule/config/` directory but in the `myproject/myapp/modules/mymodule/validate/` directory. YAML validation files look like the following:

    methods:
      get:  [new_email, new_password, new_password2]
      post: [new_email, new_password, new_password2]
    
    names:
      new_email:
        required:     Yes
        required_msg: Please enter an email address
        validators:   emailValidator
    
      new_password:
        required:     Yes
        required_msg: Please enter a password
        validators:   passwordValidator
    
      new_password2:
        required:     Yes
        required_msg: Please confirm your password
    
    passwordValidator:
        class: sfStringValidator
        param:
          min:        4
          min_error:  Your password needs at least 4 characters
          max:        12
          max_error:  Your password can not have more than 12 characters
    
    emailValidator:
        class: sfEmailValidator
        param:
          email_error:  The email you entered is not valid

For more information about form validation and the use of the validation configuration files, report to the [form validation chapter](validate_form.txt).

Browsing your own YAML file
---------------------------

Whether you want to create a new config handler, or to read a YAML file directly, you can use the `sfYaml` class. It is a YAML parser that can turn a YAML file into an associative array:

    [php]
    $myarray = sfYaml::load('/tmp/myfile.yml');

[1]: http://www.w3.org/People/Raggett/tidy/ "HTML Tidy"
[2]: http://www.mojavi.org/                 "Mojavi"
[3]: http://www.mojavi.org/                 "Mojavi project"
